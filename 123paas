
O’Reilly精品图书系列
PaaS程序设计
Programming for PaaS
（美）卡尔森（Carlson，L.）　著
潘黎萍　余水清　译
ISBN：978-7-111-48245-1
本书纸版由机械工业出版社于2015年出版，电子版由华章分社（北京华章图文信息有限公司，
北京奥维博世图书发行有限公司）全球范围内制作与发行。
版权所有，侵权必究
客服热线：+ 86-10-68995265
客服信箱：service@bbbvip.com
官方网址：www.hzmedia.com.cn
新浪微博　@研发书局
腾讯微博　@yanfabook
目录
O’Reilly Media，Inc.介绍
译者序
作者介绍
封面介绍
前言
第1章 开发者的云
1.1 开发者的困境
1.2 云能为创新做什么
1.3 云：发展历程简介
1.4 云的核心技术
1.5 管理平台与产品化平台
1.6 云计算的承诺（或者炒作）
1.7 云技术的未来5年
1.8 兑现承诺
第2章 什么是PaaS
2.1 魔术网站
2.2 开发者早期的选择
2.3 PaaS：综合两种方式的最佳方案
2.4 PaaS：现代应用的虚拟工具
2.5 重建信心
第3章 PaaS类型
3.1 不可移植的PaaS：遵照一个模板
3.2 可移植性：不再繁琐
3.3 走向公开标准
第4章 遗留应用迁移到PaaS
4.1 初步考虑
4.2 概述
4.3 资产托管
4.4 会话管理
4.5 缓存
4.6 异步处理
4.7 SQL
4.8 NoSQL
4.9 各种陷阱
第5章 在PaaS上开发新应用程序
5.1 分解庞然大物
5.2 将API应用于移动开发
5.3 JSON和REST的出现
5.4 使用基于REST的元服务
5.5 PaaS的独特贡献
5.6 摩尔定律的影响力
第6章 PaaS上的移动应用
6.1 移动应用开发简史
6.2 未来应用
6.3 数据结构
6.4 调用移动客户端的元服务
6.5 PaaS如何让移动后端开发更容易
6.6 服务于更多用户
第7章 核心服务简介
7.1 非PaaS核心服务
7.2 评估PaaS服务
7.3 采用托管的数据库和PaaS以节省时间
7.4 缓存和PaaS：冗余
7.5 解决Email的挑战
7.6 监控的重要性
7.7 负载测试
7.8 计划升级途径
第8章 为什么不选择PaaS
8.1 公共云与私有云
8.2 中小型公司：如何选择
8.3 大型企业级用户：如何选择
8.4 PaaS的限制
8.5 直面阻力
8.6 以长远的视角看待限制
第9章 PaaS的未来
9.1 OpenStack的影响
9.2 保持开发选项的开放
9.3 故障：开发者必须面对的最大问题
9.4 通过开源重新获取控制
9.5 最终的思考
第10章 资源
10.1 PaaS供应商
10.2 IaaS供应商
10.3 托管服务
10.4 将遗留应用迁移到PaaS
10.5 新兴PaaS应用开发
O’Reilly Media，Inc.介绍
O’Reilly Media通过图书、杂志、在线服务、调查研究和会议等方式传播创新知识。自1978
年开始，O’Reilly一直都是前沿发展的见证者和推动者。超级极客们正在开创着未来，而我们
关注真正重要的技术趋势——通过放大那些“细微的信号”来刺激社会对新科技的应用。作为
技术社区中活跃的参与者，O’Reilly的发展充满了对创新的倡导、创造和发扬光大。
O’Reilly为软件开发人员带来革命性的“动物书”；创建第一个商业网站（GNN）；组织了影
响深远的开放源代码峰会，以至于开源软件运动以此命名；创立了Make杂志，从而成为DIY革
命的主要先锋；公司一如既往地通过多种形式缔结信息与人的纽带。O’Reilly的会议和峰会集
聚了众多超级极客和高瞻远瞩的商业领袖，共同描绘出开创新产业的革命性思想。作为技术
人士获取信息的选择，O’Reilly现在还将先锋专家的知识传递给普通的计算机用户。无论是通
过书籍出版，在线服务或者面授课程，每一项O’Reilly的产品都反映了公司不可动摇的理念
——信息是激发创新的力量。
业界评论
“O’Reilly Radar博客有口皆碑。”
——Wired
“O’Reilly凭借一系列（真希望当初我也想到了）非凡想法建立了数百万美元的业务。”
——Business 2.0
“O’Reilly Conference是聚集关键思想领袖的绝对典范。”
——CRN
“一本O’Reilly的书就代表一个有用、有前途、需要学习的主题。”
——Irish Times
“Tim是位特立独行的商人，他不光放眼于最长远、最广阔的视野并且切实地按照Yogi
Berra的建议去做了：‘如果你在路上遇到岔路口，走小路（岔路）。’回顾过去Tim似乎每一次都
选择了小路，而且有几次都是一闪即逝的机会，尽管大路也不错。”
——Linux Journal
译者序
智能设备和互联网应用的日益普及诞生了一系列层出不穷的新概念和新技术，以满足日
益增长的数据量和人们的计算需求。云计算无疑是其中非常吸引眼球的技术之一。
然而，即使是从事云计算相关研究和开发的人员也不一定能区分清楚云计算到底有哪些
相关技术，其背后的发展历史是怎样的，以及未来的发展方向。因此，虽然云计算这个概念被
IT厂商、开发者以及各种规模的企业热炒了数年，但真正落地并开花结果的还真的不多见。
作为一名资深的开发者，Lucas Carlson无疑见证了应用开发架构的发展历程，从构建简单
的网站，到创建AppFog这一基于Cloud Foundry的平台即服务公司，这一切促成了他对云计算
平台的深入了解。因此，本书作者基于他自身的深切体会和资深的开发经验，论述了PaaS技术
的发展历史、各类PaaS平台技术的优缺点、如何向PaaS上迁移遗留应用、如何开发新的PaaS应
用、什么情况下可以采用PaaS以及什么情况下不能采用PaaS等一系列的问题。无论对于新接
触PaaS还是已经采用了PaaS一段时间的资深人士，都可以从这些话题的论述过程中进一步加
深对PaaS的理解。
尤其值得一提的是，在本书中，作者还给出了各类PaaS技术和服务领域非常流行的平台、
工具、框架和核心服务的资源，从而可以帮助PaaS研究人员和开发人员快速地踏上PaaS应用
之旅。
对于个人创业者、IT运维人员、技术主管或者平台架构师来说，都应当读一读这本书，我
相信，在深入了解PaaS的前世今生的基础上，在洞悉了各类PaaS技术优缺点的前提下，再结合
一些自己的思考必定会诞生出明智的解决方案。
“大数据，微应用”必然是未来计算技术的发展趋势，选择一个合适的PaaS技术和平台必
然可以使你轻装上阵，从而创建更快、更可靠、更具伸缩性的应用。
对我本人而言，本书的翻译过程也是一次对于PaaS知识的全面梳理过程。感谢机械工业
出版社编辑的信任和支持，同时也感谢家人的理解和支持。由于译者水平有限，不当之处还请
批评指正。
余水清
作者介绍
Lucas Carlson创建了AppFog，这是一家采用Cloud Foundry的PaaS公司，该公司于2013年被
CenturyLink收购。Lucas是一位有着10年开发经验的专业开发者，专注于Ruby on Rails的开发工
作。Lucas还与他人共同编写了《Ruby大全》（http://shop.oreilly.com/product/9780596523695.do）。
他还用不同的编程语言编写了数十个库，并且为其他很多库共享过代码，包括Rails以及
RedCloth。他的个人网站为rufy.com（http://rufy.com/）。
封面介绍
本书封面上的动物是普通的野兔（兔属），是家兔的近亲，但比家兔体形大、体格健壮。野
兔能够适应多种不同的栖息环境，因此是世界上分布较广的陆地动物之一（在欧洲和北美更常
见）。
在所有较小型的动物中，野兔是跑得最快的动物之一，可以达到每小时45英里。强有力的
后腿，再加上比较大的脚掌，给了野兔快速奔跑的能力。野兔还可以轻松地跳过较远的距离。
野兔是食草动物，主要吃野草、草本植物以及农作物。
一般情况下，野兔喜静，但在春天的时候行为会发生变化，这个时候可以看到它们在广阔
的田野里相互追逐。这是雄兔们在相互竞争领地（以便拥有更多处于繁殖期的雌兔）。在整个
春天的竞赛中，可以看到野兔们在“拳击”：一只野兔用它的脚攻击另外一只。
野兔经常被用作象征性的符号，其含义随文化背景的不同而不同，它们还是民间传说和
故事中很常见的动物。野兔经常和月亮神联系在一起，预示着新生和复活。它是多产、肉感的
象征，因此也是狩猎对象。
前言
编程很艰难
编程是一项很艰苦的工作。相当艰苦。当你完成代码编写并且编译成功，你很开心。可是
你会发现程序存在bug，这耗费了你几小时、几天、甚至几周时间去查找、定位、解决这些问题
和边界情况。当你完成所有编码并且认为不会再有更难的问题了，你还得部署代码：Vim
apache.conf.vim my.cnf.vim/etc/host.iptables。当你觉得你是一个程序员时，突然你深深陷入了系
统管理的泥潭中，完全不明白怎么会这样。
程序员比较擅长的事是创造性的偷懒。当一个程序员重复做同一件事情时，总有一天他
会想：难道我的电脑无法帮我完成吗？大概在2005年，世界上很多程序员的改编使得
apache.conf文件变化巨大。几位杰出程序员决定他们再也不愿意这样继续下去。
DevOps和PaaS两种模式的横空出世改变了应用部署模式。DevOps对apache.conf文件编辑
工作的回应是：我可以编写代码模板（称为技巧或者大全）来帮我完成系统管理。PaaS对
apache.conf文件编辑工作的回应是：我能编写程序来帮我进行系统管理。于是很多关于DevOps
的好书问世了，例如Dan Bode和Nan Liu合著的《Puppet Types and Providers》或者Stephen
Nelson-Smith写的《Test-Driven Infrastructure with Chef》，但是几乎没有关于PaaS的书。
PaaS很棒！你在专有主机上获得的好处（例如每个应用都运行在自己的进程并系统负载
均衡）在共享主机上能轻松获得（你不需要做任何配置管理，PaaS替你完成了）。但是这些好处
是有代价的。你必须编写能够在PaaS环境下运行的代码。
编写PaaS代码
很多书籍没有涉及这个主题：哪个编程模式最适合于PaaS以及哪个反模式不再适用于
PaaS环境？这就是本书的核心内容。虽然PaaS的流行度以指数级增长，以至于世界上百万计
的开发者已经接受PaaS，数百万人开始学习它，但并没有多少书面资料可以用于指导开发者
们如何成功地将PaaS最佳实践应用于他们的编码过程，以发挥PaaS的最大功效。
具体地说，当下很多开发者们面临的最大挑战之一就是如何将遗留代码和旧应用移植到
PaaS模式下。几乎没有这方面的资源指引他们战胜挑战，希望这本书提供的资讯交流能给读
者正确的指引。
本书读者对象
这本书是写给那些想要更多了解平台即服务（PaaS）的程序员、开发者、工程师和架构师
的。
当然，对于非程序员来说，也可以从本书中发现价值。实际上，如果你正想要说服你的老
板在公司内部使用PaaS，你可以给他看这本书。或者，你可以去本书第8章里找关于PaaS利弊
的一些资料跟老板讨论。这会让老板觉得你是认真思考过这个问题并得出了一个有理有据的
观点，而不仅仅是随波逐流。
在有些技术章节，我甚至给出了代码样例。既然PaaS可以与很多编程语言协同工作，因此
我提供各种编程语言的简单样例，包括PHP、Ruby、Node.js、Java，以及Objective-C。我们没有
深入介绍任何一种语言，而是在相对较高的层面上进行讨论，因为我们希望你能熟悉一到两
种并能读懂其他的语言。
本书组织结构
如果你是一位架构师或者技术管理者，或者刚开始接触PaaS，前三章对于理解PaaS技术
背景非常重要。这些章节阐述了什么是云（第1章），PaaS是什么（第2章），以及不同PaaS技术及
相对的优缺点（第3章）。
如果你已经了解PaaS的历史或者已经使用过某种PaaS平台，你可以粗略浏览前三章，仔
细研读接下来的第4~6章。这几个章是本书的核心，提供了实际有效的工具、方法和编程模式
来帮助你远离PaaS编程中的重大误区，少在编程反模式上浪费时间。
第7章是每个人都需要重点理解的一章。数据库服务和缓存服务或者邮件服务囊括了PaaS
中的一些重要注意事项。如果不细心的话，这些就是采用PaaS时最容易出错的地方。
接下来的两章回到对那些行而上学的问题的讨论上，以加深理解。第8章讨论了全盘采用
PaaS是否恰当，包括优点和缺点。明白PaaS是否适合你正在处理的问题是至关重要的。第9章
的讨论围绕着PaaS的发展方向、一些行业发展趋势，以及关于PaaS领域开源运动的思考。
最后一章介绍了跟PaaS相关的所有可用的技术，因此可以给大家提供很好的参考。你应
该在第10章放置一个书签，因为你可能会要翻到这章去发现一些灵感和观点，因为这里介绍
了所有类型的服务提供者和技术（PaaS、IaaS、SaaS和有用的代码库）。
本书的约定
本书使用了以下排版约定：
斜体（Italic）
用于新术语、URL、电子邮件地址、文件名与文件扩展名。
等宽字体（Constant width）
用于表明程序清单，以及在段落中引用的程序中的元素，如变量、函数名、数据库、数据
类型、环境变量、语句、关键字等。
等宽粗体（Constant width bold）
用于表明命令，或者需要读者逐字输入的文本内容。
等宽斜体（Constant width italic）
用于表示需要使用用户提供的值或者由上下文决定的值来替代的文本内容。
注意：表示一个技巧、建议或一般性说明。
警告：表示一个警告或注意事项。
示例代码的使用
本书提供代码的目的是帮你快速完成工作。一般情况下，你可以在你的程序或文档中使
用本书中的代码，而不必取得我们的许可，除非你想复制书中很大一部分代码。例如，你在编
写程序时，用到了本书中的几个代码片段，这不必取得我们的许可。但若将O’eilly图书中的代
码制作成光盘并进行出售或传播，则需获得我们的许可。引用示例代码或书中内容来解答问
题无需许可。将书中很大一部分的示例代码用于你个人的产品文档，这需要我们的许可。
如果你引用了本书的内容并标明版权归属声明，我们对此表示感谢，但这不是必需的。版
权归属声明通常包括：标题、作者、出版社和ISBN号，例如：“Programming for
PaaS（O’eilly）.Copyright 2013Lucas Carlson and Doug Baldwin，978-1-449-33490-1”。
如果你认为你对示例代码的使用已经超出上述范围，或者你对是否需要获得示例代码的
授权还不清楚，请随时联系我们：permissions@oreilly.com。
联系我们
有关本书的任何建议和疑问，可以通过下列方式与我们取得联系：
美国：
O'Reilly Media，Inc.
1005Gravenstein Highway North
Sebastopol，CA 95472
中国：
北京市西城区西直门南大街2号成铭大厦C座807室（100035）
奥莱利技术咨询（北京）有限公司
我们会在本书的网页中列出勘误表、示例和其他信息。可以通过
http://oreil.ly/programming-paas访问该页面。
要评论或询问本书的技术问题，请发送电子邮件到：
bookquestions@oreilly.com
想了解关于O’eilly图书、课程、会议和新闻的更多信息，请访问以下网站：
http://www.oreilly.com.cn
http://www.oreilly.com
还可以通过以下网站关注我们：
我们在Facebook上的主页：http://facebook.com/oreilly
我们在Twitter上的主页：http://twitter.com/oreillymedia
我们在Youtube上的主页：http://www.youtube.com/oreillymedia
致谢
首先，我想要感谢Doug Baldwin协助整理书稿，如果没有他这本书将无法完成。
如果没有Meghan Blanchette的耐心和坚持以及Mike Loukide的信任，我将永远不会开始或
者完成这本书。
感谢Kara Ebrahim、Meghan Connolly以及O’eilly所有成员，你们的努力让本书得以呈现！
如果没有技术审核员，这本书的质量将难以这么完美，他们发现了很多缺陷、问题和概念
上的错误，他们是：John Purrier、Alex Parkinson、Larry Hitchon、Andrei Matei、Chad Keck和Troy
Howard。
谢谢我的妻子、儿子、女儿、爱犬、妈妈、爸爸、兄弟等，谢谢你们一直以来的支持和爱。
最后，感谢创造了PaaS的程序员和发明者，以及支持他们的公司，谢谢你们让我们的生活
变得更简单。
第1章　开发者的云
不久前的一天，Jason Gendron突发灵感。
自己是不是能创建一个Twitter朋友圈，用户可以相互交流，而不只是一个跟一个的模式
呢？于是，Jason，这位来自芝加哥的程序员，开始编写代码，注册
twitclub.com（http://twitclub.com）域名，将应用部署在专用服务器上，大获成功。几个月时间，
超过80000用户使用这个服务。但成功总是伴随着挑战——人们常说的，只要能成功便非常高
兴去面对的挑战。
由于拥有80000用户，Jason一半时间用于运维，一半时间用于开发。他花在现有应用运维
上的时间越来越多，几乎没有时间创新。不久之后，黑客攻击了他自己配置的服务器。黑客们
发送了几TB数据，从而给Jason留下了巨额账单。最终结果是：他的时间都用来应付服务器而
没有足够的时间再去更新代码。
仅仅几个月之后，Jason采用了平台即服务（PaaS），将维护职责（从软件升级到安全补丁）
外包给PaaS。收效显著。自此他不用再考虑维护方面的工作，全权交给PaaS供应商处理。这
样，他就可以把所有时间都放在创新上。很快他就能辞去白天的工作，全身心投入到自主创业
中，带领公司扭亏为盈。
PaaS改变了Jason的生活，同样也会改变我们的。它能让我们从服务器管理中解脱出来专
心于编程。
Jason经历的困境很常见，其解决方案——将服务部署在PaaS上——很有前景，基于云的
开发是未来发展的方向，更简单也更经济。
1.1　开发者的困境
开发者到处都是，他们工作于小公司、政府机关、企业或者自己创业。所有开发者都在面
临相同的挑战：处理开发过程的运维事项。工作环境的不同使得问题看起来不同，其实核心问
题是一样的。
例如，让我们回顾一下传统的瀑布开发过程。通常，开发者编写代码并在开发/测试环境
里成功运行。然后就交付给IT团队，在这一环节的运维人员花几周甚至一个月时间验证应用
的质量并实施部署，造成应用产品化的极大延迟。工作超期，产品测试延迟，最终，也许最难
以承受的后果就是减缓了创新的速度。
速度，或者缺少速度，就成为一个问题，尤其在社交和手机应用方面。开发者需要赶一个
营销活动，也许只有几周时间。采用这种典型的、按部就班的流程会浪费我们很多时间，尤其
当应用存在问题需要修改时，或者仅仅是因为没有足够的速度以应付如今的社交化市场活动
的要求。
另一种情况是小公司的开发者们只想完成工作，每个开发者——就像Jason Gendron一样
——都努力构思着下一个Instagram或Facebook。PaaS帮助他们解决速度的问题，节省大量资源
让他们专注编码。
展望未来，节省的资源给自主创业提供了非常积极而深远的影响。
1.2　云能为创新做什么
云改变了开发者的软件开发模式，提升了开发者的工作效率，从风投创业公司直到大财
团世界100强公司。
现代开发者被要求尽可能高产出。他们要在紧张的预算和更紧迫的时间内实现完美的开
发工作。云的价格和便捷性被大众普遍接受。云帮助公司开发者绕开IT部门，为企业家提供对
无限量数据中心的高效访问，而且无需任何前期硬件投入。
图1-1记录了风险资本从2001年开始的近10年投资交易情况。该图展示了标准化后的交易
总量和交易规模数据的对比情况。从图中可以看出，几年内两组数据非常接近。但在2006年出
现分化，那年Amazon公司联合EC2以及S3推出了亚马逊Web服务，基础设施即服务（IaaS）成为
主流。从那时起，云分离了两组数据线，慢慢地交易规模变小而交易数量增加。
图1-1：总交易规模与标准化交易总量对比，2001~2010年
这意味着什么？又有哪些深层次的含义？
历史上第一次，交易总量和交易规模数据相互分离。到2010年，风险投资者们投入到新公
司的资金只有以往的一半。这些高科技企业不再需要那么多资金。有了云，他们不再需要搭建
数据中心。这是采用云之后风投的最大收益。
通过采用IaaS和PaaS等云技术而节省出的50%的资金可以用到各种业务上：不仅包括创业
以及风投支持的公司，还包括中端市场和大型企业。
基础设施即服务解决了一半问题——购买和管理数据中心。另一半问题是应用运维管
理。将运维从开发中分离出来是云的第二个承诺，这也是唯有平台即服务才能够提供的。
1.3　云：发展历程简介
什么是云？这个外来术语被过度使用。
Dropbox就是所谓的云么？或者是iPhone？还是Gmail？
对某些人来说，这些林林总总的例子也许就是所谓的云，但对开发者而言不是。
对开发者来说，云是相互关联的一组基础技术，借助这些技术可以采用新的方法来构建
和运行新的技术。如果用户不能在基础技术上开发新技术，那就不是云。
很多应用和SaaS都是基于基础云技术构建的。Dropbox和Gmail就是建立在基础云技术上
的SaaS应用。但它们本身不是云技术。
20世纪90年代数据中心开始增长。第三方公司将服务器集中安置在房间中，然后出租。相
比之前公司需要自己购买服务器建设数据中心，这会便宜很多。
随着集中式数据服务器的增长出现了虚拟化技术，这标志着进入云时代的第一步。应用
虚拟化，数据中心可以将大量服务器组合然后划分成小型（虚拟化的）服务器。早期涉足虚拟
化的公司中，Vmware和微软公司开发的软件对虚拟化的发展至关重要。
1.3.1　API引入
在2006年，继虚拟化之后云的进一步发展是：应用编程接口（API）。API增加了一层复杂的
自动化层，这样用户可以通过简单、实时的命令控制、启动、停止以及创建新的虚拟机。继亚
马逊公司首创推出了亚马逊Web服务之后，API为基础设施即服务的出现铺平了道路，它的很
多规范是我们现在公认的云标准的前身。
云发展到此时，批量创建大量虚拟机已经是轻而易举的事，但如何管理是个头疼的问题。
用户身边触手可及的大量服务器该如何管理呢？DevOps粉墨登场啦。
1.3.2　DevOps出现
2010年前后DevOps成为主流。它源自于开发者更快完成工作的需求。开发者厌倦了代码
部署运维时的等待，没有工具去进行服务管理，手工完成所有工作。为了摆脱这些困境，程序
员们转向云技术，并成为DevOps的鼻祖。他们构建系统来管理和维护基础设施，并且用程序
来完成与服务的交互。
DevOps推出Chef和Puppet这类重要的工具，可用于管理几千台服务器、升级代码、更新代
码、更新服务、部署新的服务器实例、修改配置，而这些工作对开发者来说是极其繁琐和困难
的。于是，DevOps的自动化工具，例如RightScale和ScaleXtreme，也开始兴起。
在所有云工具中，DevOps为开发者提供了最好的控制管理。代价是用户仍需要花时间去
构建和管理系统。如果事情不顺利，仍然由开发者负责处理。所以，DevOps并不是开发者的最
终方案。这就是原因。
作为开发者，可能需要花时间编写基于Chef和Puppet的代码，但是最终的目标可能是尽量
从系统运维中解脱出来。如果是这样，现在的平台即服务可以解决系统管理问题，给开发者节
省更多时间。有了PaaS，我们不需要编写Chef指南或者Puppet脚本去管理服务器，可以将更多
的时间放在编写与用户交互的编码上。
DevOps一直是应用程序生命周期管理工具的基础技术，我们后面会花点时间探讨一下。
应用程序生命周期管理离不开DevOps，因此DevOps不会消失。DevOps属于核心基础技术，在
云领域中更是不可或缺的。
DevOps工具也是PaaS如何后台运行的重要组成部分。例如Heroku、EngineYard、AppEngine
以及AppFog等平台，DevOps工具都是后台运行的核心组成部分。
1.3.3　应用程序生命周期管理的诞生
由于有了DevOps，人们可以轻松管理上千台机器，但它仍然与硬件设备紧密相关。相比
于具体细节（例如，虚拟机上安装什么版本的libxml）应用程序更关心服务（例如，MySQL和
MongoDB）。DevOps，甚至IaaS，都没有实现服务和应用管理。下一层次的云技术是应用程序
生命周期管理。
应用程序生命周期管理工具技术以Cloud Foundry、Open-Shift以及Cloudify等为代表。它们
还不是真正的PaaS（尽管有时他们自己宣称是），因为它们仍然需要操作员来人工操作（并未将
操作员从实际操作之苦中解脱出来）。但是，它们为PaaS技术奠定了基础。这些工具知道怎么
启动、停止和部署应用。它们也知道如何运行和管理诸如MySQL之类的服务。
应用程序生命周期管理工具全面接管应用，支持跨服务器管理应用，因此，应用可以运行
在上百甚至上千台服务器上。一般来讲，IaaS和DevOps工具对分布数百台服务器上的应用
——需求、资源以及服务，考虑欠佳。应用程序生命周期管理了解应用，为它们提供服务，知
道如何管理、扩展以及维护它们。
很多情况下，我们可以在笔记本电脑上运行应用程序生命周期管理工具。Cloud Foundry
的微VM就是很好的证明。OpenShift和Cloudify也有类似的工具。应用程序生命周期管理进一
步产品化的任务艰巨，即使很小的产品安装也需要5~10个人的团队，管理几十或者几百台机
器。
应用程序生命周期管理能带来很多好处。例如，一个文档管理网站可能整夜遭遇严重的
网络堵塞。我们需要依次处理好1000多台服务器上众多的新用户。
在应用程序生命周期管理概念出来之前，我们需要安排一个团队人为处理好几百台新服
务器的增加工作。我们需要部署好代码。这些工作都需要人工干预以及人力资源协调。
即便采用DevOps，这也是一项艰巨的工作。我们如何确定Puppet自动创建的服务器运行
正确呢？我们如何维护这些服务器呢？我们如何实时监控应用加载对各个服务器的影响呢？
这些正是DevOps工具的缺点。
Cloud Foundry之类的应用程序生命周期管理工具改变这一切。只需要告诉Cloud Foundry
你的应用需要1000以上的实例，它就会自己完成所有工作。这就使得跨服务器的应用更新升
级变得无比简单。
但问题仍然是有的。我们仍然需要有人监控应用程序生命周期管理软件，还是没能完全
摆脱人工操作。我们只是将注意力从一个应用换到生命周期软件的运行情况上。
在我们的样例中，在有应用程序生命周期管理工具之前，当需要增加服务器时，开发团队
需要和实际操作团队密切合作才能保证升级成功。有时候必须是原始团队，甚至是原来的人
员或者两者都要满足，只是角色分开。操作人员需要手工完成所有服务器的联调工作。
现在，应用程序生命周期管理工具能帮我们完成所有的工作。它了解应用，知道怎么执行
代码，知道怎么添加服务器和实例。但是应用程序生命周期管理工具自己需要操作者。我们需
要运行这个工具。区别在于它是一个抽象的工具，我们可以装载任何应用或者其他东西。作为
一个开发者，不管运行这个工具的操作人员是跟你同处一室坐在你旁边，还是在几百米之外
的地方，例如波特兰、俄勒冈州，都没有关系。
于是我们进入了NoOps和平台即服务领域。
1.3.4　新一代云——平台即服务
云使得我们再也不会陷入巨大开支，不再需要购买服务器、系统以及涉及的人工费用。
以往，创业者们都有着相似的经历。我们需要雇用一些有资质的员工，花百万美元在数据
中心以及管理等事情上。
和基础设施即服务一样，云的核心理念以及最大好处就是减少购买数据中心的投入。我
们不再需要购买数据中心，但仍然需要操作人员管理我们租用的服务器。
NoOps方案则完全不需要操作人员与开发人员的密切协作了。操作需求也能满足，但完全
与每个独立应用无关了。NoOps方案主张将运维工作外包，让开发者更快地完成任务。开发者
不需要等另一个团队来部署他们的代码，而是由系统自动衔接完成这些工作。
NoOps方案也是有争议的，因为有人会将它读成“没有，运维”，暗示运维会越来越无所
谓。恰恰相反，运维现在越来越重要。NoOps的真正目的也是让开发者更重视运维，但我们不
再需要直接完成应用程序维护工作。就像NoSQL并不是指SQL不再重要，而是会有另一种方式
实现数据存储和恢复，而开发者不再需要直接与SQL交互。
平台即服务外包了运维工作。这并不是不要运维工作，而是从开发工作中分离出来，这样
开发者的工作越来越简单，效率越来越高。
平台即服务管理的原始迭代包括Force.com（http://force.com）和Google应用引擎（Google
App Engine，GAE），很受限制。他们要求必须基于他们的API进行开发，这样他们只需要按他
们的语法工作。他们的平台即服务的特点就是跟他们的系统捆绑密切。他们承诺用户可以获
取特别数据，充分利用他们平台的特长，例如自动扩展，完成这类比较困难的工作。
早期的PaaS有两个缺点。第一是我们需要学习一整套API接口，这就有一个学习适应的过
程。第二个缺点是可移植性。例如，我们是基于Google的App Engine平台开发的，想要将应用移
植到其他平台上很困难。当然平台的优点也很多，例如它们提供的收集系统数据和服务。
随着新演员的出场，诸如Heroku和EngineYard的平台发生了变革。他们打破了开发者必须
依赖于他们的API接口的说法。实际上，他们认为“我们将全盘接受你的应用。你可以使用专用
的API接口，在我们的系统上运行你的代码将如同运行在自己的设备上一样容易，你不需要做
任何修改”。对开发者来说，这是云计算发展中一个历史性的变革。
最初，PaaS为了保障变革性的服务限制了语言。例如，Heroku和EngineYard的早期用户只
能使用Ruby语言。所以优点是我们编程可以不用依赖于API接口，但是必须受限于选择的语
言。
PaaS在新一代PaaS平台公司（AppFog和dotCloud）的帮助下迅速改进，不再要求使用某一
特定语言。现在很多大型PaaS公司或者老牌公司，例如HeroKu和EngineYard，支持很多编程语
言。从限制性平台到更加开放的平台代表云技术的重大进展。
有些PaaS公司仍然绑定使用某一种语言，但他们承诺能因为精通这种语言而给出更多好
处。
在像AppFog这样的PaaS公司中有一种发展趋势就是多基础设施PaaS。我们可以同时在很
多设备上运行我们的应用，哪怕是多个公司提供的设备。这是云技术发展过程中第一次用户
可以同时在亚马逊Web服务器和Rackspaces上跑应用。如果亚马逊Web服务器宕机了，
Rackspaces就像热备系统一样继续运行我们的应用。PaaS所能实现的正是程序员们想要的。
1.4　云的核心技术
对开发者来说，“云”是一个外来术语，并被注以各种解释。云是怎么协助开发者更快更好
地完成工作的呢？想要明确知道什么是简单应用、什么会改变我们的生活是很困难的。
对有些人来说，云就是Gmail、Dropbox这类的服务。其实这些是建立在云上的应用。它们
并没有改变开发者的生活。真正改变开发者的生活的是支撑云的核心技术。
基础云技术是虚拟化、基础设施API、DevOps、应用程序生命周期管理工具以及NoOps。
它们相互支撑组成了新一代云，彼此不可或缺。例如，没有虚拟化就没有基础设施API。
作为开发者，掌握任何一种基础技术都受益匪浅。例如，我们可以直接使用虚拟化。很多
DevOps也是如此，直接管理KVM或者Xen，通常虚拟多种操作系统来测试应用。我们可以通过
虚拟化提供各种环境来测试应用，不用考虑它是一个软件应用、网络应用还是移动应用。
在虚拟化上使用API接口，很多开发者在亚马逊Web服务器以及类似的OpenStack API上开
发，这样可以更快更好。这样他们可以迅速扩展服务器并管理过程和程序包。
但问题是，当服务器在凌晨4点宕机时，开发者们总是第一个被通知的。服务器在凌晨4点
宕机是不可避免的事，即便我们采用了虚拟化技术、基础设施API、亚马逊Web服务器和Cloud
Foundry。
作为开发者，工作中一半问题是如何获得我们需要的资源，基础设施即服务能解决这个
问题。另一半问题是运行和管理我们的应用，这就是平台即服务擅长的。
从开发者的角度，我们可以运用任何核心技术。采用越高层次的技术，我们越可以留更多
时间编码。作为开发者，我们可以把时间花在IaaS层：可以更好地控制底层设备。现在的趋势
是我们需要把时间用在VMs上，较少时间放在用户编码上。
在云技术领域里，采用越高层次的技术，越接近PaaS技术，就越有更多的时间创新。你才
有时间成为Jason Gendron并且开发出自己的产品，围绕用户需求进行各种尝试，研究出下一代
Google或者Facebook的建设方案，完全不用再去担心凌晨4点服务器宕机的事情。
1.5　管理平台与产品化平台
关于PaaS的讨论集中在管理化或者“公共云”PaaS上，开发者或者公司可以将运维工作外
包给PaaS平台提供方。而一个产品化或者“私有云”PaaS则是不同的特性。
在一个产品化平台上，我们基于自己的硬件设备资源运用应用程序生命周期管理工具以
及平台即服务工具。这样的优点是：我们的维护团队是完全可控的。他们可以整合我们所使用
的各种平台工具，因为他们很熟悉这些工具的工作原理。另一个优势是运维人员可以重复利
用我们投入的设备，并做好系统优化。
类似HeroKu和AppEngine之类的管理式平台供应商正面临运维需求的挑战。如我们之前
看到的，平台即服务最大的优势之一就是将开发者从运维工作中解脱出来。一旦这两者分离
了，运维就可以在任何地方完成。你不禁会问，“运维工作是由自己完成时便宜，还是外包给供
应商更经济实惠？”
管理式平台采用了PaaS平台技术，它可以实时提供服务，用户不再需要担心服务层的一
致性。平台能确保服务的正常运行时间，因此当凌晨4点出现有问题时，公共供应商负责来处
理，而不是用户。
产品化平台有很多。例如Cloud Foundry或者OpenShift这类企业预置型的平台都有开源的
应用程序生命周期管理工具。更多的是类似于Cloudify和Stackato这类需要购买序列号的商业
工具。像AppFog之类的公司则提供公有云和私有云两种平台，内置相同软件。
在我们自己的设备上运行像Cloud Foundry这样的应用程序管理工具是很困难的。因为这
些工具的产品质量服务需要很多相互作用的组件。想要确认这些组件工作良好、管理有序、一
旦有问题能成功替换等事项是很复杂的。这些是由管理式平台来完成——但如果运行在自己
的设备上，那就得我们自己去面对了。
1.6　云计算的承诺（或者炒作）
从开发者的角度来看，这个兴盛的新兴领域的部分挑战决定了云计算是不是都是炒作。
对于一个开发者、公司或者政府机关，Gmail究竟能有多大改变？可能不会很大。它也许
是有一定先进性，但绝不是变革性的。然而，学会在现代化公司的运维工作中充分使用基础云
技术，例如DevOps或者PaaS，无论你是刚开始使用还是正在使用，只要这些技术能让我们的
工作更简单高效，那就不是炒作。相反，这正是高科技公司创建和运维的模式。这是事实。毫
无疑问，我们正迎头迈入云计算时代。
当技术产生于技术时，它将以指数级速度循环增长。想想，例如从摩尔斯电码到现代电话
的发展经历了40多年，而现代技术的成熟快得惊人。通信行业的摩尔定律就是一个例子，它发
现了集成电路中的晶体管数量每两年翻一番。在高科技公司以及云技术领域，创新的速度越
来越快。新基础技术从创建、产品化，到成熟的时间周期越来越短。产业的重大变动时间周期
也比前些年短。近些年，虚拟化被广泛接受大约花了10年时间。IaaS的成熟用了不到5年。PaaS
的广泛使用可能只要1~2年时间。
作为一个开发者，学会熟练掌握这些技术是在如今这个时代成就自己职业生涯的关键。
1.7　云技术的未来5年
PaaS已经成熟起来，但仍不适用所有应用。新一代Twitter或Facebook会建立在PaaS上么？
答案是“不一定”，但至少大部分公司都认识到移植到PaaS平台上的好处。
2013年，PaaS还没被广泛接受，就像2006年的Ruby on Rails。一些大公司采用PaaS取得了
成功（例如，Groupon使用EngineYard）。一旦出现一些更大的成功故事展示了PaaS的巨大潜力，
我们很快就会看到PaaS的广泛使用了。
另一个影响接受度的因素是PaaS是否适用于大公司的防火墙。Heroku和EngineYard是很好
的云计算解决方案，但是公司已经耗巨资购买的大量服务器不可能立刻报废。在基于现有硬
件设备的PaaS上运行大型应用还需要一段时间才能被广泛接受。
展望未来的5~10年，PaaS将是基础技术方案。我们将见证新一代高科技公司都建立在云
之上。我们将看到百万美元资产的企业完全依靠PaaS技术。
1.8　兑现承诺
在这章开篇，我们看到PaaS改变了Jason Gendron的生活。PaaS让他专注于自己的天赋、一
心编码和管理公司，为他的创新节约成本。PaaS为他节省出时间，给他提供强大的服务器，帮
助他实现TwitClub。通过移动IaaS提供商的需求、管理每天的运维事项、处理故障和宕机事件，
PaaS改变了数以百万开发人员的生活。
无论你是在政府机关需要处理数百个客户端，在公司有几千个用户或者在自己创业，
PaaS都提供工具帮你挖掘你的潜能。
它减少了开发者自己创新的代价，减少了风险投资者们投资新一代Google的代价。当公
司普遍接受PaaS后，它能将节省的资金投资到公司上。
在下面的章节中，我们将进一步走进PaaS和管理服务，检查怎么基于PaaS开发应用，展望
将来PaaS成为云技术领域的主角。
第2章　什么是PaaS
开发者正在转向PaaS，以便更好更快地完成工作。
更快：因为不再需要设置和管理服务器或者等待别人来做这些事情。
更好：因为PaaS可以实现最佳实践，而不需要通过思考。
开发者在面对不同的挑战时，通常都会有自己独一无二的思考方法。在开始写作本书之
前，我自己曾经遇到过一些挑战，这些挑战来自于童年时代创建网站的成功，这个成功最终演
变成了灾难性的失败，而我从中吸取到的教训直接影响到我现在的编程。
2.1　魔术网站
1996年，我们家签约购买一个国际互联网连接，并且获得了一个和互联网服务提供商绑
定的主机账号。我下载了Fetch，一个免费的FTP客户端，然后找到了一个WebMonkey教程学会
了基本的HTML编程。之后，我输入了FTP的密码，开始了Web编程之旅。一想起世界上每一个
人都将会看到我的“世界，你好”的Web应用程序，我就激动不已。这个简单的应用改变了我以
后的生活。
我热衷于魔术。因为我发现花费几天甚至几周，仔细地练习手部动作之后所产生的短暂
的特技效果所带来的感觉令人着迷。所以，我想把我对于魔术技巧的激情和对这个称之为Web
的新鲜玩意的激情结合起来。因此，我建立了我的第一个Web页面，一个供魔术师们交流想法
和技巧的页面。刚开始的时候，这只是一个简单的HTML页面，随后迅速演变成一个动态的
PHP网站，我称之为“魔术嘉年华”。
随着社区的成长，“魔术嘉年华”变得越来越动态，不停地增加新的内容、功能以及设计。
为数众多的魔术师们在此分享他们的技巧和窍门。网站还提供了一些测试，访客通过这些测
试之后，才能看到这些技巧和心得，这样就确保了只有真正的魔术师才可以访问这一内部圣
殿。
网站很快增长到需要一个自己的服务器的时候了。看到“魔术嘉年华”被托管在一个专用
的主机上，我不禁激动万分。到了2001年，成为排名第一的魔术网站，有成千上万的会员和不
计其数的技巧分享。在那段岁月里，我给网站安装和配置了Apache和MySQL，花费了无数个夜
晚对其进行调整优化，只为一切能正常工作。
后来，突然有一天，当我醒来的时候，发现网站瘫痪了。我试着登录服务器，但是没有成
功。我给服务器提供商写邮件，没有任何回复。于是，我不停地给他们写邮件，几天之后，终于
得到了回复，他们回道：“对不起，你的服务器挂掉了。”
我问道：“我的服务器挂掉了是什么意思？”
和很多之前和之后的开发者一样，我根本没有机会得以备份我的服务器。因此，我丢掉了
所有的数据、魔术技巧、用户。让我感到讽刺的是，这台服务器表演了一个最大的魔术：让所有
的一切在瞬间消失了。
这就是我第一个网站的最终结局。
对于我来说，这是一段痛苦的经历，同时也是一段非常重要的时光，它深深地影响了我以
后的职业生涯。若干年后，当我开始使用平台即服务的时候，终于可以实现源自于这段痛苦经
历的梦想，那就是创建了被称为AppFog的PaaS服务供应商。
2.2　开发者早期的选择
不幸的是，扩展问题和数据丢失的情形非常普遍，主要是由于上一代应用开发者几乎没
有太多的选择。大部分人要么选择共享web主机，要么选择专用web主机。如今，我们可以在两
者之间加入一个更为强大，并且相对比较新的选择，那就是所谓的平台即服务。在我们深入平
台即服务之前，先来检视一下前两种方案。
2.2.1　共享web主机
通常认为，web开发者刚开始的时候使用共享web主机是一种最容易的方式。例子包括
GoDaddy、Yahoo！、Comcast以及如今的很多互联网服务提供商。
共享主机的核心概念就是一个FTP账号，即为登录FTP应用服务器而获取的凭证信息。这
个服务器通常托管着几千个，甚至数万个网站。一般情况下，服务器是非常强大的，但是会很
快陷入困境。如果这些网站中有一个或者两个开始出名，即使服务器能力非常强大，也会很快
耗尽所有的服务器资源。于是会出现这样的结果：上千个网站变得异常缓慢，甚至没有任何响
应。
使用共享主机有利的方面就是价格。共享主机价格便宜，有时候还是免费的。而且，是不
需要手工维护的。开发者不需要安装安全补丁包、不需要管理软件、也不需要深入地理解软件
是怎么编写的，只需要知道怎么编写HTML代码就可以了。开发者将写好的HTML代码交给服
务商，后者会处理其他所有的事情。但是，由于非常便宜，服务供应商可能无法将所有的事情
都处理得很好。例如，由于不能超出计算能力的限制，因此导致无法扩展规模。但是，对于简
单的应用来说，通常还算不错的。
虽然，对于主机托管供应商来说，规模上比较划算，但这并不是非常可靠，尤其对于需要
搭建一个网店、一个复杂的网站、甚至一个给客户提供稳定的联系信息访问的网站等应用。
另外一个不足之处就是安全。你的代码可能与其他10000份代码共存于一个系统之上。记
住，一个普通的网站每天遭到数百次的安全攻击是很容易的。将这一数据乘以10000，就可以
看到将正式的网站放在共享主机上的风险有多大了。
尽管有这些缺点，开发者依然觉地使用共享主机来托管个人网页、分享观点或者尝试新
的想法，还是比较有用的。共享主机比较适用于开发时还不确定是否需要投资独立的服务器，
并且还不需要面对规模扩展问题的时候。但问题是，一旦需要扩展，从共享主机迁移到独立主
机会经历一段痛苦的过程。
2.2.2　独立主机
由于共享主机便宜而且易于使用，因此，开始的时候，开发者——尤其是web开发者——
通常会选择共享主机。但在经历了这一阶段之后，通常都会转向独立web主机。这和在家里通
过互联网托管自己的服务器一样简单。但是，独立主机也会依据不同的选项，提供不同级别的
服务和可伸缩性。
以下是可供选择的独立主机类型的一个列表，按照控制程度（通常也是性能）降序排列：
·托管服务器
·管理服务器
·虚拟私有服务器
·基础设施即服务
下面我们来深入探讨一下每种类型。
托管服务器
使用服务器托管，你通常得自己购买服务器，然后将服务器安置在一个可以通过宽带连
接的数据中心，并按月付费。托管数据中心提供互联网访问，有时候也帮助调试或者重启服务
器。但是，除了需要预先花钱购买服务器之外，你还得自己负责维护和管理服务器。
管理服务器
“管理服务器”这个名词有点不是那么恰当。事实上，对于服务器的管理是非常有限的。如
果RAM损坏了，服务商会把内存换掉。如果其他硬件有问题，服务商也会将这些硬件换掉。但
是，在RAM或者磁盘被换掉的时候，他们并没有把你的数据换回来。因此，对数据进行离线备
份就相当必要。
采用管理服务器有许多不同的好处。通常，不需要自行购买服务器，只需要从托管和管理
服务器的供应商那里直接租用就可以了。相对于其他独立主机方案来说，管理服务器可能更
快，更稳定和健壮。管理服务器也会挂掉，但一般不会那么快。通常是在磁盘失效的时候，而
磁盘的平均失效时间在一年或者两年左右。对比起来，亚马逊的Web服务中短暂的服务器，差
不多每隔几天或者几个星期就会宕机。管理服务器不利的一面，就是通常需要几个星期甚至
一个月的时间来开通新的服务器。
虚拟私有服务器
虚拟私有服务器，或者VPS，与管理服务器非常相似，但它是虚拟的。在桌面环境下，
Parallels、VirtualBox以及Fusion等虚拟机软件可能广为人知。对于服务端虚拟化来说，可以使
用的工具（也叫管理程序）包括XenServer、KVM、Virtuozzo、VServer以及Hyper-V。
通过虚拟化，可以将拥有若干TB字节的RAM和数百个处理器核的大型服务器划分成若干
个拥有GB的RAM和1~4个核的虚拟服务器。这就可以比较容易地启动和运行服务器，而且相
比非虚拟化的独立服务器来说，更容易替换。
虚拟化技术可以使每个虚拟服务器在安全方面独立于其他服务器，相对于以多宿主方式
在一个Apache实例上共享服务器的形式来说，以一种更为全面的方式隔离进程和宿主程序。
每个虚拟机都有自己的Root账号，这个账号在遭受攻击的时候，没有办法访问其他的虚拟服
务器。
VPS也有其不利的一面，那就是由于底层的物理资源也是可以共享的，那么其他的宿主程
序就有可能过多地占用你的处理器和磁盘I/O，从而以一种非预期的方式降低程序的性能。
基础设施即服务
基础设施即服务类似按需使用的、易伸缩的、具备一个应用编程接口（API）的虚拟私有服
务器（VPS）。从可用性的角度来看，这是独立主机最快的实现方式。但是，由于依然需要获取
Root访问权限，因此这依旧是一种独立Web主机。与其他主机托管方式最大的不同在于，IaaS
可以让服务器在30秒之内启动并且运行。Iaas可以是独立的真实的服务器，但通常是虚拟服务
器。可以用来实现虚拟化的软件从VMware的vSphere到Xen，从Citrix到微软的Hyper-V。最流行
的Iaas就是亚马逊（Amazon）的Web服务，它采用Xen来虚拟化硬件。
使用IaaS的时候，可以得到一个独立的服务器以及一个专有的IP地址。但是，必须自己完
成所有的系统配置和管理：安装软件、安装和配置Apache、配置安全属性、优化服务器、优化
MySQL、增加账号、分发密码、设置SSH、生成SSH的密钥、安装和升级软件包，以及确保应用
软件与服务器上的其他软件相互兼容。
采用IaaS的好处在于，可以按照实际需要获得任意数量的服务器，并且可以非常快地完成
扩充。不利的一面在于，这些服务器通常要比其他独立主机方案慢。由于没有办法提供高性能
和高可靠性，通常这些服务器的运行都是短暂的，意思是可能在没有任何通知的情况下就宕
机。因此，必须从系统的角度进行设计，以专门处理非预期的服务器宕机，这就增加了复杂的
层次。
比较成本
这几种独立Web主机的成本构成差别很大。
主机托管方式，开始的时候需要支付购买服务器的固定成本，然后只需要在托管数据中
心租用场地即可。因此，相对于小规模的IaaS来说，后继成本极低。很多大型应用都采用了主
机托管的方式，通过硬件的投资来节约每个月的成本。这也被称为通过增加资本支出（capex）
来减少日常运营成本（opex）。主机托管的成本也有所不同，可以在刚开始的时候每月花费大
约1000美元租一个机架，最多可以放置16台服务器。记住，采用主机托管，开发者仍然负责维
护和管理这些服务器，因此开发者需要进入数据中心，安装机器，将它们相互连接，并且在服
务器出故障的时候，自己去解决问题。
相对而言的另一端，即采用IaaS的时候，则要按照实际需要使用的资源，按小时支付特定
的费用（也称为通过增加日常运营成本来减少前期的资本支出）。通常，有很多不同的组合方
案可供选择，包括不同的CPU速度、磁盘大小以及I/O性能。
由于IaaS通常按小时付费，并且不需要长时间的保障，因此在短时间之内需要很多服务器
的时候就非常方便，例如，在一定量的数据之上进行大规模计算。这个应用场合会对预算造成
多大的影响呢？
假设我们需要进行DNA测序。这一工作有着确定的一组问题以及一组数据。使用IaaS，就
可以启动上千台服务器，在特定的时间之内完成DNA测序，然后再关闭这些服务器。那么整个
过程只需要为使用这些服务器的实际时间支付费用。如果购买上千台服务器，那么完成DNA
测序之后，服务器将无事可干，而采用IaaS则只需要按照实际需要付费。
Web应用的生命周期通常要比DNA测序程序长很多，因此，表面上看来，采用capex可能要
比opex更划算些，因为可以得到长期的服务。采用IaaS的方式来托管Web应用就不那么经济
了。但是，由于Web应用程序可能会遇到访问峰值，因此，当考虑到准备上一场脱口秀或者一
项新节目的时候，我们就必须要准备好应付随之而来的网站访问流量地增长。当采用服务器
托管方式时，必须首先购买服务器，等待几周的时间，然后将它们放置到数据中心，并花费数
周的时间安装配置。而采用基础设施即服务的方式时，则可以每天24小时的调用自动化的应
用编程接口，并且可以在数分钟之内加入上千台服务器。在访问流量减少之后，则又可以释放
这些服务器，并且仅需要为实际使用的时间支付费用。
使用IaaS最常见的问题就是，由于服务器通常都不是永久的，因此，必须采用某种方式的
持久化块存储，用于保存数据。例如，当采用MySQL作为数据库时，在服务器宕机而又不想丢
失数据的情况下，就必须要将数据持久化到块存储设备或者其他类似的持久化存储设备上。
这些服务以及其他一些服务需要额外按小时付费。
基础设施即服务是一种按需所求的系统。因此，可以按照实际需要增加服务并且按小时
支付费用。
2.3　PaaS：综合两种方式的最佳方案
对于开发者来说，通常会以共享主机的方式起步。很快，就会经历需要更强的功能和控制
的阶段，于是，就会转向独立主机托管。在完全拥有了控制权之后，你可能会感到很惬意，也
会很兴奋，因为你可以对服务器进行调整和优化，让它们运行得更快，网站可以更快地的被加
载，并且可以处理更多的用户请求。
然后，随着时间的流逝，兴奋感很快就会烟消云散，因为日复一日维护服务器所增加的负
担，会让人筋疲力尽。独立服务器可以提供更强的功能和控制，但是很容易就会遭受攻击，而
作为开发者，你必须自己解决这些问题。在数据库被破坏了的时候，还得自己去使用备份数据
进行恢复。
而且，还有更多问题！而不仅仅是需要花费时间和精力来管理这些机器。如果服务器在
凌晨4点宕机（通常会在这些非常不方便的时间发生），你必须完全负责去修复它。即使你在吃
晚饭、在参加婚礼或者在度假，你也得去修复机器。这就是寻呼机存在的理由—为了找到医生
和系统管理员。
简而言之，对于开发者来说，共享Web主机很容易，但是无法提供足够的控制和功能；而
独立主机虽然功能强大，但是也带来了很多麻烦和不必要的负担。在平台即服务出现之前，没
有任何折中的方案可以选择。
于是，结合独立主机托管的强大功能和共享主机的易用性，我们便得到了平台即服务。
2.3.1　开发者的圣杯
让我们简单回顾一下这个例子，由于新增的电视节目，导致网络流量地爆发增长。采用专
用服务器托管时，就必须从1台服务器增加到100台服务器。这将是一个梦魇，因为我们可能需
要雇佣一个团队来管理这些服务器。但是采用平台即服务的方案，则只需要将滚动条从左边
移动到右边，数秒钟之内就可以将服务器增加到100台。
就像我们所看到的那样，平台即服务提供了专用主机所拥有的强大的能力、速度、可靠性
以及可扩展性，同时也如同共享主机那样简单易用。因此，我们可以说，平台即服务是开发者
的可扩展性和可靠性的圣杯。
同时这一增强的可靠性也带来了另外一项好处，那就是作为可扩展架构的关键原则之
一，应用于现代Web开发领域的N层架构。
2.3.2　共享负载
采用N层应用架构，我们就不需要将应用的逻辑与数据库服务器，或者缓存服务器或者负
载均衡服务器放置在一起。因为，可以采用不同层次的服务器来独立地处理应用程序的不同
的方面。
这样就实现了垂直方向的扩展，从而可以通过增加更多某种类型的服务器来增加运算能
力，这些服务器并行运行，并通过软件的配置实现负载的分发。于是，我们就从原来的单一服
务器，到现在拥有了至少三层或者四层的服务器，或者层次。在每一层中，我们都得以复制失
效恢复和高可用性。
而在采用专用服务器的时候，通常需要东拼西凑才最终得以实现类似的架构。每一个平
台即服务的方案都从开始就拥有内置的N个层次。这些层次被打包成产品，并在刚开始的时候
就成为一种事实上的标准，将专用Web主机与一种简单的部署应用代码策略组合成一种最佳
方法。
2.3.3　语言上的考虑
有多种不同的方法来实现平台即服务。一些供应商专注于某种单一的编程语言，就是说，
开发者被限制于应用特定的语言。比如Java、PHP、Python或者Node.js。
也有些供应商提供多种不同的语言以供选择。一方面来看，多语言供应商可以提供一站
式服务的好处，而另外一个方面，单语言的平台即服务供应商则常常可以提供高度优化的系
统环境。总的来说，应用最广泛的PaaS系统通常都是多语言的。
作为开发者，大家还需要注意供应商锁定问题。某些平台即服务供应商要求应用系统编
程的时候，使用他们的应用编程接口（API），因此，一旦将代码绑定到他们的API之后，就很难
移植到其他的平台了。如果这只是简单的在数据库服务的层面上，应用的代码还可以保持不
错的可移植性。但是，如果使用了供应商定制的库或者定制的应用编程接口，就很难将这些集
成点切分成相对独立的点，因此，难以将应用程序移植到其他PaaS平台。
2.3.4　PaaS定价
几乎所有的平台即服务供应商总会让人免费尝试。通常，我们可以至少免费地建立一些
应用程序。对于开发者来说，这通常是非常有用的，因为可以通过尝试熟悉平台即服务。在准
备部署产品应用的时候，我们就会有很多不同的选择，这些定价模型通常依据所选择的不同
平台有很大的不同。PaaS部署产品应用的价格可能从每月只有20美元到每月上万美元。
例如，采用某个业界领先的PaaS供应商的服务时，通常可以免费地部署应用。但是，当需
要扩展应用，并增加更多实例的时候（让应用进入产品准备阶段），可能就得按照每个实例支
付费用，每个实例大约每月30~40美元。如果还需要备份服务，就还需要每月增加30~40美元的
费用。因此，对于某些平台即服务供应商来说，支付的成本可能随着应用的扩展而迅速增加。
其他的平台会采用不同的定价模型。有些按照实际使用的虚拟机数量收费，也有些按照
某个资源消耗模型收费。采用AppFog，开发者就拥有一定数量的RAM，基于这些RAM可以按
照需要部署特定数量的应用，或者一定数量的实例以运行这些应用。按照每个月使用多少
RAM支付费用，而不是如何使用付费。doCould也采用类似的模式。
2.3.5　PaaS真的是个新事物吗？或者只是IaaS++
这里有好几个问题。平台即服务是个新的概念吗？或者它只是基础设施即服务的一种扩
展？这一“伟大构想”是否是按需提供的服务器加上API的概念组合？或者平台即服务是一个
全新的，完全不同的思想？
有足够的证据表明IaaS和PaaS各不相同，而且平台即服务并不是基础设施即服务的一个
特性。归根到底，问题是对于每种服务来说，什么是重要的。
在IaaS和PaaS背后的核心概念是什么？换种方式说：什么是它们的基础单元？
基础单元
一个基础单元就是所研究实体的最小的不可分解的单元。什么是最小的公共元素？什么
才是人们所关心的基础的、不可分割的方面？数学上，就是数（或者更为基础的集合）。物理
上，就是方程。化学上，就是分子。而在生物学上，就是细胞。
这一概念也同样适用于商业世界。对于麦当劳来说，就是汉堡。对于巴诺（Barnes&Nobel）
书店，就是书。对于可口可乐，就是一听可乐。这些就是一个公司最在乎的基础单元。
搞清楚一个公司的基础单元，既有一定的启发意义，也有一定的限制性。启发性在于它可
以让人更为专注，集中精力于所擅长的方面。而限制性在于很难销售任何不在公司基础单元
之外的东西。很少有尝试多个基础单元的公司能够成功。
基础单元并不一定要如前面所述的那样具体。例如，对于亚马逊（Amazon.com），其基础单
元就是任何可以被放置在仓库中管理，并且可以被包装在一个盒子中运输的东西。对于
Netflix，就是多种形式的数字媒体。对于Procter&Gamble来说，就是居家用品。
在谈到挑选基础单元这个问题时，有很多令人困惑的地方。其中部分原因在于很多销售
着不同基础单元的公司被组合到了一起。一种从根本上理清这个问题的途径，就是从一般的
层面上去了解每个公司的基础单元。
IaaS与PaaS的对比
对于基础设施即服务，基础单元就是资源。这里的资源是指服务器、磁盘、网络以及IP地
址。IaaS所做的一切就是按照需要提供这些资源。例如，亚马逊（Amazon）的Web服务，所有的
工具都以资源为中心，所有的文档都是关于资源的，所有的开发都是专注于资源，同时人们也
因为需要这些资源而使用它。其他一些IaaS的例子还包括Rackspace、GoGrid以及Joyent。
对于平台即服务来说，基础单元就是应用。那么什么是应用？就是一个系统。这就是代码
以及所有那些在任何时候都与这些代码通讯的服务。这不仅仅是资源，事实上，一个应用是由
很多单独的资源绑定在一起组成的。将所有这些资源连接在一切所需要付出的工作量通常被
低估了。这就是为什么很多公司成立IT部门，以及为什么系统管理员总是非常受欢迎的原因。
从一个单一地运行Apache和MySQL的服务器转移到一个拥有单独的负载均衡服务器、缓存服
务器、应用服务器、数据库服务器以及冗余的失效恢复的系统架构需要大量的工作，包括前期
投入以及后期维护。
利用PaaS可以做的另外一件事情，就是从应用的角度来管理IaaS。诸如Cloud Formation之
类的工具是非常了不起的，但它们是通过资源的角度来管理IaaS。从应用的角度来管理IaaS与
资源完全不同。
与资源不同，应用通常不会频繁地上线下线。对于IaaS来说，虽然按照实际需求每小时付
费的定价模式非常有用，但通常没有那么重要，除非面对应用的爆发式增长或者在一个测试
或开发场景中。
简单地说，平台即服务供应商面对的是代码和服务。这些供应商的职责就是管理和维护
代码、运行服务并且确保在任何时候，所有的一切能正常连接并正常工作。
2.4　PaaS：现代应用的虚拟工具
在过去的数十年中，应用开发发生了巨大的变化。从早期的在计算机上运行编译的代码，
到客户/服务器架构，再到现在的REST应用编程接口（API），编译和运行代码的工具也发生了
很大的变化。
2.4.1　转向高级语言
让我们回到早些的那个例子：需要一个程序进行DNA测序，这个程序要运行得尽可能快，
因此，我们可以使用诸如C或者汇编的底层语言，以便获得尽可能高的性能。
使用PaaS，通常需要构建Web应用程序，延迟并不是那么的至关重要。对于运行在PaaS上
的不同类型的应用程序来说，最具价值的质量特点在于快速创建相关部分并将它们连接在一
起的能力。高级语言，特别是诸如Ruby、PHP、Python以及Node.js之类的动态脚本语言，要比其
他底层语言更好地适合这一要求。
因此，在PaaS中，通常会采用数十年前主要被视为脚本语言的语言。现在这些语言成为企
业助力他们的应用系统的强大工具。作为世界上最大的网站之一的Facebook就使用PHP来助
力他们的系统。Yahoo！也使用PHP。Twitter最初构建于Ruby之上。Linkedin一开始使用Ruby，
之后换为Node.js。因此动态语言被越来越多地应用于构建Web内容。
2.4.2　管理后端
新一代的编程语言也产生了新的开发风格：基于更小的代码段得快速迭代，更快速地将更
小以及更易扩展的应用投入生产。通常，构建的应用都是API类型的应用。这类应用（在更大的
规模上）使用API与Web前端进行通讯，包括Gmail、Twitter以及MobileMe。也可以被用于移动
应用，以保证一个移动应用可以让用户注册以及让用户之间相互交流。所有的这一切都必须
通过API以及后端服务才得以完成。
相对于初次构建这个移动应用，管理一个移动应用的后端，通常要花费更多的时间，这就
是平台即服务作为这样一个虚拟工具的原因。如果你有一个应用在Apple应用商店排名前10
位，那么你就得确保后端的应用能够随着用户地增长而扩展，以便能够处理每分钟来自用户
手机的上百万次的访问请求。传统上，要做到这一点需要一个由IT和运维人员组成的团队。平
台即服务给了我们管理成百上千的后端应用的能力，这一切只需要简单的一个滚动条，而不
是一个团队。
如果这些还不够清楚，通俗点说，就是PaaS将控制和能力交还到开发者手中。最后，我们
不再需要寻呼机。虽然，PaaS无法去掉代码中的缺陷，但是，很显然开发者可以完全不用再关
注任何硬件或者基础设施的失效问题。
2.5　重建信心
在我丢失了网站数年之后，平台即服务开始出现。平台即服务的出现可以让应用程序更
容易以更快的方式运行。现在，备份应用程序可能只需要点击一个按钮。开发者不再需要担心
服务器宕机，因为自然有人维护这些服务器。PaaS重建了现代开发者部署应用的信心和激情。
随着采用PaaS并充分利用其功能，接到可怕的电话：告诉你服务器挂掉的时代一去不复返
了。
第3章　PaaS类型
在前面的章节里，我们简单讨论了移植的概念，即将应用移植到不同系统上。虽然可移植
性在很多情况下是一种充满吸引力的特性，但是，我们依然需要权衡可移植和不可移植的
PaaS。
3.1　不可移植的PaaS：遵照一个模板
采用不可移植PaaS的平台即服务，我们就可以基于这个平台的独特规范和API编写代码，
从而创建应用。
这意味着我们的代码结构需要严格依附于特定的模板或应用编程接口（API）。这些API可
能主要集中在服务数据库、存储架构或者搜索架构上。而其他时候，API属于低层次并且面向
编码的。有时候我们必须使用专门为那个平台所构建的特定语言。
正如我们所看到的，这种平台里有各种不同类型的“钩子”，使得它可移植性较差。最早形
式的平台即服务就是建立在这种结构化很强的想法之上。这些从早期实践中诞生的雏形，逐
渐形成了我们现在的平台即服务。
但问题很快就出现了：为什么我们必须基于私有API编写代码呢？难道为了这些优势以及
对数据的访问就得失去灵活性？在我们检视新生代公司针对这个问题的回答之前，先看看不
可移植PaaS领域里的几个主角。
3.1.1　Force.com
作为Salesforce的开发者平台，诞生于2008年的Force.com（http://force.com），允许开发者扩
展Salesforce的功能从而创建应用，而Salesforce（http://www.salesforce.com）则是一个非常流行
的SaaS客户关系管理（CRM）销售工具。这是我们知道的PaaS的鼻祖之一。Force.com激发了一
代应用，数以千计的开发者开发了新的应用来访问、分析Salesforce丰富的数据。
Force.com的平台即服务提供Web服务的应用编程接口以及工具集、一个用于创建应用的
用户接口、一个用于存储数据的数据库以及基础的网站托管功能。最近，平台添加了移动功
能，使得基于Force.com的PaaS平台开发移动应用也一样便捷。
使用Force.com的缺点是：开发者不能随意使用编程语言创建通用应用。应用逻辑层建立
于Apex之上，它是运行在Force.com上的一种强类型、面向对象、类似于Java的语言。优点是基
于Web的接口创建新应用相对简单、便捷。我们可以选择自己想要的数据类型、创建数据结
构，可以自动生成Web和移动设备界面并收集数据。
在数据输入选项的基础上，我们也能加入公式、审批程序、发送邮件，并且测试快速、简
单。Force.com的PaaS平台有自己的Force.com集成开发环境，开发者们测试、部署应用都很快
速、简单。
当我们在Force.com平台的约束下工作时，不需要去考虑扩展、管理应用问题，Salesforce
替我们完成了。PaaS正是采用了这些基础理念，才能获得如此的流行度。
随着Force.com平台的成熟，它支持越来越多的服务：例如
Database.com（http://database.com），提供定制接口和数据输入，为全世界近100000商家提供数
据库服务。
3.1.2　Google App Engine
Google App Engine（http://developers.google.com/appenqine/），也是2008年发布的，是PaaS
最早版本之一。GAE的承诺是：开发者们可以挖掘Google的巨大能力、利用Google运算资源，
以及使用Google的设备和运维设备的专家技术。但我们的应用必须遵守Google的标准。Google
不仅建立了运维团队，还有一整套工具和系统，以及其特定的工作方式——他们这种工作方
式正是为了扩展到“Google规模”。
我们探讨的是什么样的规模呢？在这种规模里，我们需要成千上万台设备来解决一个问
题。当我们面对像Google这么大的规模时，工具要非常规范。为了能够处理海量数据，就必须
这么做。毫不夸张地说，Google基本上处理了整个互联网的数据。GAE的中心思想之一就是如
果遵照它的标准，我们的应用也可以具备这些强大的功能，而且只需要支付使用的那部分功
能的费用。
GAE为什么不支持可移植的原因很明显。只有在我们按照Google的一套规则使用时，才
能接入它现有的基础设施。一方面，我们得按照Google规定的方式编写代码。另一方面，如果
这么做，我们就能获得在Google的规模上运行程序的好处。
很多PaaS平台都会有各种限制。当开发者面对不可移植的PaaS，例如GAE，那些限制是很
严格的。开发者必须得尽可能遵从这些规范，才能充分运用GAE的特长。
使用GAE，对于访问文件系统、内存访问、能使用的内存数量以及每个进程能运行的时间
都有限制。
这些局限性迫使开发者想其他办法。例如，假设我们有一个网站需要编译很多清单列表，
并计算列表上的数据项。在传统主机环境里，当一个用户访问这个网站，传送结果需要相当多
的时间。所有过程必须在结果返回给用户前完成。根据处理的复杂度，这一过程很容易，大概
需要数秒的时间。
GAE的另一个局限是：我们的应用需要很长时间才能获得结果。如果不能很快返回，GAE
就会杀掉这个进程。
如果应用在设计的时候就知道不能运行很长时间，这对用户体验来说其实是开发中的一
个积极因素。这迫使开发者问自己：“如果不是简单地按我通常的做法，Google会让我怎么做
呢？”因此，可以创建一个缓存，每当用户访问网站时从缓存中取出数据填充到列表中，而不
用每次都编译这个列表。缓存能很快响应并提供最佳的用户体验。为了后台编译缓存，我们可
能需要用另一套Google工具，以一种可扩展性更强的方式来做运算，然后将结果放到缓存数
据库里。
GAE有很好的前景和很大的客户份额。它的承诺——充分运用Google的资源——使得它
成为不可移植PaaS领域的典范。
3.1.3　Windows Azure
微软也在努力思考如何创建一个PaaS平台。微软的.NET Framework专家引导公司围
绕.NET来思考最佳实现方式。2008年，微软发布了Windows
Azure（http://www.windowsazure.com）。
公司着手创建一组库。其设计考虑是：如果开发者将这些库包含在他们的系统中，Azure就
可以利用这些库来扩展系统。微软也提供可扩展的标准服务。
有了Windows Azure，我们就拥有了一些基础系统，例如消息总线和队列系统，以及一组
满足应用不同需求的选项。这些为开发者提供了一些模式，以支持他们创建基于互联网互通
的分布式应用。如果我们融入了微软提供的库、技术和服务，就可以利用Azure系统简单而快
速地扩展应用。
最近，微软开始脱离不可移植Azure系统，去除一些将开发者捆绑到特定服务上的需求。
允许扩展到不同语言和技术，从而将Azure慢慢转型到可移植领域，这就不需要为了适应平台
而调整代码。因此，Azure从不可移植起步，现在正慢慢转型到可移植。事实上，微软最近发布
了一个可移植版本的平台即服务。
3.1.4　不可移植PaaS总结
尽管所有这些PaaS选项开始是不可移植的，很多平台都开始添加功能使得自己越来越可
移植。GAE发布了PHP支持服务，需要做的修改越来越少。Windows Azure也发布了PHP支持服
务，而且开发者可以做得更多，而不用像以前那样依附于微软的接口。
3.2　可移植性：不再繁琐
可移植PaaS是这样一种平台，在其上运行的代码编写完成之后，就不需要进行较大修改。
开发者在共享主机或者专用主机上开发的代码迁移到可移植PaaS上不再那么困难。想要运行
应用不再需要依赖服务转接器。
平台仍然存在局限性，这是需要应对的挑战，但这些局限相对代码来说更偏功能性。
可移植性扩大了平台即服务支持的语言数量和类型，也扩大了语言自身的灵活性。如果
我们想要将应用移植到不同的可移植PaaS平台上，需要调整应用的某些内容，但不需要彻底
改写系统。
相对而言，看看早期的Google App Engine，那时候只支持Python。我们需要运用某些功能
编写特定版本的Python。这给了我们很大的限制：例如，我们不能运行Python最流行框架，
Django。现在的可移植平台即服务上不会再遇到这种问题。
3.2.1　Heroku
Heroku（https://www.heroku.com），创建于2007年，是最早支持可移植平台即服务的公司之
一。Heroku看到Force.com和Google App Engine的发展，总结出对于开发者们来说，可以编写任
何代码要比必须基于平台的接口编码更有意义。
Heroku公司起步的时候，只支持Ruby的平台独立性，即Ruby编码能以任何形式部署。后来
被Salesforce.com公司所收购，并且扩大了语言支持。但Heroku仍然不支持用户访问文件系统。
这样就可以更为简单的为用户应用创建多个实例（Heroku称之为dynos）。如果我们要上传或修
改一段代码，最终只需要运行一个实例，如果我们的应用运行需要100个实例，由于上传的文
件不能传播，就会导致不一致的实例。为了避免这个问题，Heroku的措施就是开发者不能写入
文件系统（除了短期的临时目录）。
对于Google的App Engine，每个应用也有一定的生存期（Heroku会更常见一些）。但也有些
后台运行的任务，完成一些异步的工作。这些想法是由Heroku提出的，并设定了可移植平台即
服务的早期标准。
Heroku和Google App Engine的进一步比较，例证了可移植PaaS和不可移植PaaS之间的主
要区别。
对于Google的App Engine，开发者编写代码要严谨，严格调用Google的API。对于Heroku，
开发者的编码——不管它是运行在共享还是独有的主机上——都可移植到Heroku上。可移植
性的区别是：要基于供应商的系统编写代码，还是可以用更通用的方式编写代码。之所以可移
植是因为同样的代码可以从Heroku迁移到我们自己的系统上，不需要做大修改。
Heroku的另一个创新是关于代码部署。早期的PaaS产品，例如Google的App Engine，在部
署代码时都存在问题。Heroku采用了更通用的方式，创建了基于git的系统（git是一个源代码管
理工具，支持用户可以追踪自己的软件代码的版本，就像CVS和其他代码管理工具）。
对于Heroku，当我们将代码提交到git源代码管理工具上，将代码推送到Heroku就会触发部
署。对开发者来说部署代码非常快速和简单，不像一般使用FTP触发壳托管系统。使用FTP，用
户必须查找变更的文件，并确认自己上传和同步的文件。Git可以持续追踪文件变化并且留存
历史记录，这样用户不需要自己查找变化的文件。Git工具识别并将这些文件自动同步到平
台。
3.2.2　Cloud Foundry
Cloud Foundry（http://www.cloudfoundry.com）由Vmware创建，是支持PaaS的新一代技术。
相对于Google App Engine或者Heroku而言，它具有一定的创新，由一组程序和服务组成，可以
运行在用户自己的平台即服务上。它遵循开源许可（Apache 2），甚至可以运行在笔记本电脑
上。
采用Cloud Foundry，我们可以访问一组程序包和程序，提供与PaaS一样的交互和部署代
码体验。它可以管理代码并且可以按用户在PaaS平台上习惯的方式扩展或缩减。
由于Cloud Foundry是开源程序，因此与Heroku、Google App Engine和Windows Azure有着
很大的差别。那些都属于托管服务：用户不能查看源代码，也不能修改服务。本质上说，那些是
用户无法讨价还价的境况，用户将代码装入黑盒子由系统部署。
Cloud Foundry具备PaaS平台的很多特征，但不是托管式服务。如同Apache一样，用户必须
自己运行的技术。然而，它是一个灵活的分布式系统并且比Apache这样的系统要更复杂一些。
它不支持公开注册。如果用户想要注册，必须去找Cloud Foundry的供应商。他们的数量正
在增加：AppFog是一个，Vmware提供的托管服务也可以尝试。
与Heroku不同的是，Cloud Foundry创建了REST API，用以取代git部署机制，这是一个新的
部署应用的方式。它使用基于Ruby的命令行工具去部署代码。由于REST API，用户可以灵活
选择是否集成git、CVS、Subversion、Darcs、Mercurial、Team Foundation或者其他。如果用户想
要不同版本的代码控制，它不会加以规定，而是由用户自己选择。
Cloud Foundry还在如何支持第三方服务方面做出了一些创新的决定。采用Heroku和其他
平台即服务技术，用户最快获益的就是他们提供的服务、绑定应用的能力。通常，通过设置环
境变量并在应用运行时传递给它。应用读到参数获取数据库的认证。Cloud Foundry提供的机
制很相似，但它将这个服务封装——例如MySQL、Postgres以及Redis——成一个抽象概念，我
们可以绑定服务也可以从应用上取消服务。它保留一组环境变量可用，这样我们可以程式化
循环使用。
Cloud Foundry也支持用户为多个应用绑定一个数据源，这使得我们调试应用、判断它的
状态变得更为简单——不管是产品数据还是审计系统。我们可以将数据源同时绑定到多个不
同应用上。
Heroku的创新之一集中在第三方插件市场。通过这个市场，Heroku可以提供其他云工具，
使用环境变量，并将工具的认证信息传递给我们的应用。有些PaaS平台，例如AppFog，融入了
相似的理念，但是Cloud Foundry目前没有内置与第三方工具整合的功能。
绑定服务是可移植PaaS平台中特有的特征之一，这需要不同编码。当用户尝试将应用迁
移到另一个PaaS平台时，一般来说不同部分是关于连接数据库或者数据源的。也经常有不同
的需要重写的代码——通常只有很少一部分。
3.2.3　AppFog
CloudFoundry.org（http://cloudfoundry.org）提供的开源工具集是每个开发者都会用的，这推
广了平台即服务的应用范围。因为它不属于管理型平台即服务它也融入了新领域。对于开发
者来说这意味着在用户使用Cloud Foundry之前，他需要自己安装并运行。如果我们想要在产
品环境下使用，需要自己在产品环境下安装并运行，这提供了很大的灵活度，但却削弱了PaaS
与生俱来的简单性。
AppFog（http://www.appfog.com）属于管理型和维护型PaaS平台，它采用Cloud Foundry的技
术。AppFog开始是一个独立的公司，2013年被CenturyLink收购。
Heroku的另一个创新是它完全基于亚马逊Web Services，直到今天它一直运行在AWS上。
这与其他早期的PaaS供应商例如Force.com、Google App Engine以及Azure有很大的不同。那些
都创建在自己的平台及基础设施上。Cloud Foundry有两个部分：称为CloudFoundry.org的开源
库，以及称为CloudFoundry.com的专享托管平台，这个平台使用CloudFoundry.org编码。
AppFog公司也使用CloudFoundry.org编码，并且在多个基础设施和公共云系统上运行。因
此，如果它在亚马逊Web Services运行，也能与OpenStack平台兼容，例如Rackspace、HP Cloud
以及其他公司。它甚至可以在OpenStack和vSphere的私有云实例上运行。
从开发者角度，我们会发现AppFog拥有很多CloudFoundry.org所具有的拿来即用的特征。
但它运行在很多基础设施之上，为用户提供基础设施的选择和可移植性，就像编码一样。此
外，AppFog也采纳了其他平台的一些想法，例如集成第三方云服务，并整合到自己的平台中。
结果是：用户登录并在任何自己想要的云设备上运行应用，采用自己运行的技术，为用户提供
了在其他系统（例如Heroku）上需要通过第三方插件才能获得的好处。
3.2.4　dotCloud
有些平台更关注PaaS平台后的基础设施，而较少关注用户体验。
dotCloud（http://www.dotcloud.com）是第一个创新支持多种语言和技术的平台之一，它通过一
个称为Docker（http://github.com/dotcloud/docker）的开源项目推动了Linux容器的流行。
当dotCloud发布时，Heroku只关注Ruby，Google App Engine只支持Python，而Azure只支
持.NET。dotCloud则同时支持Python、Java、Ruby以及其他技术。
这个流行的PaaS平台致力于创建支持命令行的系统，与Cloud Foundry相似。它支持Unix命
令行和命令的API接口，从而支持用多种语言部署应用。
Cloud Foundry和dotCloud的区别在于如何支持语言。对于Cloud Foundry，整个系统是一个
开源工具，这意味着用户可以登录并改变应用运行和管理的方式。管理工作与Cloud Foundry
工具集密切相关。dotCloud对应用运行的方法进行抽象，用户部署应用时，可以管理应用运行
的方式，保证其符合规范。
3.2.5　CloudBees
CloudBees（http://www.cloudbees.com）是一款特别关注于Java的PaaS平台。它基于Java工
具集创建，并包含了Java平台的上使用的通用工具。
CloudBees区别于其他平台的特征是：它集成了持续集成工具，例如Jenkin。事实上，
CloudBees雇佣专人维护Jenkin，它已经成为持续集成领域的领导者。这给予了PaaS新转折点，
因为它支持系统并扩展了PaaS的应用范围。对于其他平台，其想法是让用户将代码部署到它
们的产品上。CloudBees嵌入更多开发工具来扩大其适用范围。
不同于简单地将代码部署到产品上，CloudBees提供一套系统给用户持续性地测试代码，
在代码部署到产品之前确认它没问题。用户部署代码之前，CloudBees提供一条更长的途径并
增强一些功能帮助用户适应它的平台。迄今为止，CloudBees仍然只支持Java以及支持Java的
应用。所以，尽管它扩大了PaaS平台的可用范围，CloudBees仍然只局限于一种技术。
3.2.6　总结：何去何从
对于可移植平台即服务，主要优势是用户可以轻松将现有代码部署到平台上，不用太大
修改。这个迭代更快。如果用户想要将应用从某一特定系统迁移到别的环境，可移植平台可以
将影响降到最低。
不可移植平台的优势是与平台的功能高耦合。例如，Google App Engine，其优势是能借助
于Google的基础设施和维护。对于Windows Azure，其优势是能借助于微软的维护。
如何权衡，关键在于用户想要运行哪种应用。例如，如果我们想要运行Node.js应用，就不
能选择Google App Engine。但如果想要使用Google的桌面功能，就不会想要采用Heroku或者
AppFog。选择可移植还是不可移植PaaS取决于用户的需求以及想要利用的特征集。然而，当所
有都确定了，开发者就需要在应用的路上坚持自己的想法。最后，开发者应当问问自己，代码
将来变化的幅度以及应用想要生存的地方。
3.2.7　处理好遗留应用和新应用
用户权衡PaaS选项时的另一个重要考虑是：是迁移现有应用还是创建新的应用？在回答
这个问题时，平台及服务是可移植的还是不可移植的就变得尤为重要。
如果代码已经完成，代码迁移到不可移植PaaS平台上将变得更加困难。重构一个复杂的
Python应用使得它能在Google App Engine运行，相对于运行在AppFog或Cloud Foundry上要难
很多。在Cloud Foundry上，不需要费什么力气就可以正常运行。而在Google App Engine上，它
可能需要众多工程资源。
如果是创建新应用，即从头开始并且对于语言和技术选择很灵活，那么用户在选择平台
时更具灵活性。如果用户评估技术时侧重于可扩展性和性能，考虑Google App Engine和
Windows Azure会更有收获。如果运用Google的运维和基础设施会对开发者的新应用更有帮
助，那么应该尝试Google App Engine。需要注意的是：应当提前思考并确认所选择的平台可能
会出现的重大问题，并及时应对，不要将自己困住。
另一个因素就是价格。如果开发者使用的不可移植平台价格出现变化，突然贵出很多，将
我们的应用迁移的其他供应商那会比采用可移植服务困难很多。
还有一个问题：宕机时间。几乎每个PaaS平台在某个时间都会出现可靠性问题。如果我们
的应用只能在某一个平台上运行，当某个时刻平台宕机时我们就是在冒险。如果我们的应用
创建得比较健壮能在很多种可移植平台上运行，当平台出现可靠性问题时我们就能体会到其
中的好处了。
3.2.8　运用服务
早前，我们在Heroku和Cloud Foundry内容里简单讨论了服务。采用PaaS平台的最大好处之
一就是能很快很简单地绑定平台服务，例如MySQL、memcached以及PostgreSQL。还有很多关
联好处：有了服务，用户就可以快速启动，服务完成了管理和维护工作，而且通常平台会做好
备份并提供冗余。
缺点同样也有。对有些平台，访问数据很困难并且很难查看运行中的服务状态。而有些服
务，特别是那些SQL家族的，以扩展性较差著称。当应用壮大时，最大的问题之一是确保掌握
自己数据库系统的情况。用户想要能监控代码与数据库交互的所有细节，从而优化自己的数
据库。
这是一个权衡的过程。一方面，用户体验不到控制的感觉。而另一方面却有很大的优势：
即自动化管理。
当服务以邮件形式出现，服务模板是一个重要的角色。由于邮件服务提供商越来越擅长
发送垃圾邮件，所以发送邮件的功能会非常难。云供应商发送邮件时他们习惯性阻止。这就会
有个问题，因为垃圾邮件发送者们会借用云上的很多服务器发送大量的邮件。因此，很多云供
应商都在黑名单之列。即使用户想发送，但发送邮件不被允许，当用户创建发送邮件的应用时
会出现大问题。很幸运，将邮件系统整合到服务模板里可以让用户快速绑定到邮件发送服务
器上，帮用户解决了这些问题，Gmail、Hotmail和很多垃圾邮件过滤器的消息都能通过。开发
者自己完成这项工作很困难。当我们创建应用时，能够轻松地掌握借助白名单里的托管供应
商搭建邮件服务是服务模板很大的优势。
3.3　走向公开标准
公开标准是平台即服务的一个重要概念，因为它们让开发者有信心独立完成与供应商提
供的服务相关的应用部署。
需要了解每个不同供应商的来龙去脉完全是个噩梦。然而，我们已经讨论过了PaaS不同
的类型和它们提供的不同种类的服务。
不可移植平台即服务开始时承诺“我们会向你的web应用提供Google的能力”提供不同解
决方案，区别于可移植平台Heroku所说的：“零修改运行你的代码”。Heroku相对于某个平台是
一套完全不同的解决方案，那个平台承诺：“我们为你打造可以在笔记本电脑桌面运行的你自
己的平台。”每个供应商都在努力解决不同的问题，对于用户创建和部署应用的方式有完全不
同的想法，从而产生不同标准，不一样的体验，以及不一样的展现。它们可能使用基于git的部
署机制、REST API或者部署专用系统。有的可能支持持续整合，而有的可能关注部署工作。鉴
于这些区别，很难以其中某一个作为标准。
3.3.1　开源的魅力
尽管一路走来出现很多不同类型的平台即服务技术，每天还产生很多新技术，最有可能
从Cloud Foundry或OpenShift上产生新标准：一些提供开源选项的PaaS。
阐述这些技术的几个强有力的因素是：用户可以在自己的笔记本电脑上运行这些技术，这
一点对尝试将PaaS整合到自己每天的工作事项的开发者们来说充满诱惑。PaaS开源社区的另
一个好处是用户理论上可以在多个提供兼容PaaS选项的供应商之间选择，甚至自己在生产环
境中运行。与之相反，除非Heroku开放其技术栈的源代码，否则用户必然被捆绑到Heroku选择
的基础设施供应商。
总之，开源PaaS的这些有利条件为创建标准奠定基础，基于它们的API创建的标准不会限
制用户使用特定设备或者服务提供商。它也扮演新兴标准的角色，指导用户如何以标准方式
在公共和私有的基础设施上部署应用。
我们已经看到开始将Cloud Foundry API作为标准使用。AppFog用它在亚马逊Web
Services、Rackspace、HP Cloud以及Windows Azure上部署应用，这也验证了一个标准的API可
以在不同后台使用。开发者通过Cloud Foundry API与这些系统交互，降低他们使用的API语言
与底层设备之间的耦合度。
每天越来越多的PaaS技术变成开源的。Cloud Foundry是最早这样做的领头人之一，之后
Red Hat开放了OpenShift、GigaSpaces支持开源云，甚至dotCloud在它的PaaS技术栈里开辟了一
片开源领域。
3.3.2　评估旧应用
如我们看到的，现在有很多PaaS供应商，适用不同需求并拥有不同的理念。当我们考虑遗
留应用迁移到云上的问题时，应当根据应用的需求考量不同平台的限制。在下一章节，我们会
深入探讨将遗留应用迁移到PaaS上，并为用户可能会面临的一些困境提供解决方案。
第4章　遗留应用迁移到PaaS
大家的衣橱都有框架支撑。以技术债务的形式出现的框架：Cobol应用，我们总打算去清
理的意大利面条式的代码，某个同事在离职前编写的没有文档记录的应用以及那些已经使用
了10年的应用，没有人知道它们的工作原理。这些通常被称为遗留应用。
在云上开发应用需要全新的视野，经常增加一些不同的编程范式。当遗留应用能采用
PaaS平台时，成功的迁移路上会有一系列挑战。
幸运的是，遗留应用迁移到PaaS过程中出现的所需要的变化，在今天已经成为了最佳实
践。无论是否采用PaaS，只要想提高应用的可靠性和健壮性，这些变化都是需要的。
4.1　初步考虑
基于云开发应用时，总存在某些特定的假设，开发者应该要了解。无论是基于IaaS还是
PaaS。
如果我们将遗留应用部署到IaaS上，最大好处是能更快地提供虚拟设备。缺点是虚拟机通
常有时限性：它们会宕机、不够可靠或者不够健壮。这迫使用户考虑在创建应用时加入冗余机
制，应用可以在很多不同服务器上运行。
这种思路与共享或者专享主机环境的思路不一样，那些环境下，用户认为服务器是不会
宕机的。不采用虚拟机制的环境下，一台服务器为一个应用提供所有服务。更大的应用就需要
将数据库服务部署到单独的机器上。通常，这种情况下不存在复制问题、数据一致性问题或者
会话管理。当用户将代码上传到这些系统时，一个隐含的假设就是它只能运行在一个服务器
上。当用户必须创建跨服务器的系统时，这个条件就不成立了。
4.1.1　规避潜在问题
采用IaaS时，必须假定任何服务器随时可能宕机，事实也确实如此。基于IaaS的PaaS产品
通常已经替用户考虑了一些潜在问题。创建多层分布式应用逻辑很难，但这正是PaaS的价值
所在。PaaS从一开始就融入了多层的概念。
基于PaaS，开发者不需要规划如何做好20台不同服务器上Apache配置；不需要考虑如何做
好这些服务器的负载均衡；不需要担心MySQL的从数据库以及主-主的复制。开发者也不需要
关心冗余、心跳以及故障转移，就像使用IaaS一样。
然而，采用PaaS，开发者编写代码时仍然要假定应用的每个实例随时可能宕掉。这迫使开
发者在创建应用时要考虑使用一些非传统的Web开发模式，特别是针对遗留应用。开发者还需
要考虑框架和内容管理系统（WordPress、Drupal、Joomla！），它们尚未与新思路同步，也没融
入多实例应用管理模式。
我们将在这章后续部分举例说明如何解决上述问题。
开发者必须自己完成这些转变，必须开始考虑如果有一些甚至很多实例宕掉，应用应该
如何处理，还要考虑如果多个实例上的文件系统不一致，应用该怎么处理。
4.1.2　常见问题
当面临与硬件设备相关的遗留应用时，我们需要思考一些常见问题：
·如果硬件设备无法提供持久化和一致性，这对应用意味着什么？
·文档上传到哪里？保存在哪里？
·应用程序对硬件设备还有哪些假定要求？
·用户会话保留在哪里？很多时候，会话状态保存在硬件设备上，但如果我们运行了几十
个、一组或者几百个实例时，从用户角度这意味着什么？
·用户每次点击网页时始终保持登录状态还是在访问间隙退出？
4.1.3　更多遗留代码问题
迁移至PaaS的过程中，另一个需要考虑的是长时间运行的进程。传统开发方式中，长时间
运行的顺序处理进程很少会出现问题。通常，应用程序会预先花费一定的处理器资源，因此需
要花更多的时间来装载，而使用Ajax或者其他一些前端处理技巧则可以掩饰这一过程。然而，
当使用PaaS时，我们必须换个角度思考长时间运行的进程。在Paas平台上，长时间运行的进程
需要单独处理，并异步于我们的主应用逻辑。事实上，如果程序运行时间过长，一些PaaS供应
商会强行停止用户的主应用。但不是所有的遗留应用都是按这种模式创建的。
这些只是传统的开发范式演进的一些方式，以及基于云的开发范式与传统开发范式的不
同之处。现在，让我们来把这些思想放在特定的上下文中来讨论一下。
4.2　概述
后面章节会讨论遗留应用迁移至PaaS过程中最普遍的一些问题。主要包括：
资产托管
用户如何处理上传的内容（图片/视频/音乐）？
会话管理
如何管理会话数据？
缓存
如何采用现代高速缓存技术？
异步处理
如何处理长时间事务？
SQL
在PaaS上使用SQL的注意事项
NoSQL
怎么运用现代的NoSQL？
各种陷阱
4.3　资产托管
当用户上传文件时，无论是简历照片、电影、附件，还是其他任何形式的文件，都属于资
产。通常，应用本地存放的那些资产是不会有问题的（存在硬盘上），因为如果服务器崩溃，用
户可以重启机器，文件仍然存在。在现代托管云上，这种假设条件不再成立。如果服务器崩
溃，基于IaaS或者PaaS供应商的文件系统经常不稳定，机器重启时系统不会重新装载。
在很多托管在云上的应用平台，不管是基于IaaS或者PaaS，当用户重启应用或者系统时，
上传的文件就会丢失。
这样做的好处是应用的新实例能简单快速启动，这是基于PaaS创建应用的基础工作之
一。不管怎样，这意味着更好更稳定地上传管理文件不仅是一个好想法，更是开发应用应该具
备的理念。在将遗留应用移植到PaaS的过程中，这是用户第一需要处理好的事情之一。
关于资产托管，当我们处理一个遗留应用，或者像WordPress和Drupal之类的内容管理系
统时，我们要处理好系统中的硬盘存储问题和特殊文件格式问题。因此，这些挑战取决于用户
是从新改造现有应用并转换成基于PaaS的现代云应用，还是尝试将WordPress、Drupal或者其
他CMS托管给在云上。如果采用前一种方式，一般的过程是采用大二进制对象（blob）存储系
统，也称为对象存储。
4.3.1　关于大二进制对象
常用的资产存储方式有两种：大字段（大二进制对象）存储，也被称为对象存储，还有一种
是文件存储。文件存储是传统开发过程中较常用的存储系统。Blob存储工作原理则不一样。它
采用键值存储并通过应用编程接口访问，例如亚马逊S3、Windows Azure大二进制对象存储、
Google云存储、Rackspace云文件或者OpenStack的Swift系统。
当有用户上传资产到应用上时，通常会在文件系统中相对稳定的地方创建一个临时文
件。而到使用大字段存储时，不同于将文件移动到目录下，用户上传资产到最终位置（通常通
过REST API）并且获得一个访问资产的惟一URL链接。一旦采用对象存储机制，API接口会给
上传资产返回一个URL，这时用户可以存储URL链接。不同于直接将对象存放在硬盘，我们现
在获得一个URL链接，而资产上传到永久存储结构中。
采用对象存储系统的好处之一是上传的所有文件，被自动复制到不同服务器上（最多支持
7~8个不同备份）。这样数据不容易丢失也更稳定，上传的内容几乎不会因为硬盘问题而遭遇
损毁。用户也不用过于担心备份问题，而数据保存在本地硬盘上就不一样了。
取决于用户采用哪种对象存储，还有其他一些好处。网络内容发布商（CDN）可以加速用
户资产的传递，因此这些资产不仅可以存放在不同地方，而且还能根据用户所在位置，从最近
的位置发布给用户。这使得用户使用资产和下载页面的体验更快、更好。
基于冗余和CDN考虑，大字段存储通常是个好主意，同时它也为用户的网站提供了更快
的速度、可靠性和健壮性。而且大字段存储实施并不太复杂。从这些代码示例中可以看出，采
用资产托管，相对于从这项投资中所获得的益处来说，前期所付出的努力是物超所值。
4.3.2　亚马逊S3上的PHP
亚马逊提供在Ruby、Java、Python、.NET和移动电话上使用S3的库。这里举例说明S3应用
到PHP应用中有多简单。这段代码不能拿来就用，因为它只包含了让人理解相关流程的代码片
段。想要获得能运行的完整代码，需要访问亚马逊的示例代码和库的页面，那里有如何使用代
码的更详细说明。不管怎么样，举例的目的是，一旦将库加载到应用之后，使用就很简单：
<?php
// 亚马逊的AWS网站上有S3.php
if (!class_exists('S3')) require_once('S3.php');
// 如果注册账户后Amazon会给用户分配一个S3的证书
// 最好的练习是配置PaaS的ENV变量
$s3 = new S3(
getenv("AWS_ACCESS_KEY"),
getenv("AWS_SECRET_KEY")
);
// "bucket"是模拟目录的名字
// 这是收集类似东西的方法
$bucket = "MyPaaSAppBucket";
// 创建bucket
$s3->putBucket($bucket, S3::ACL_PUBLIC_READ);
// 假定文件以表单元素传递
// 称为"file", <input type="file" name="file" />
// 定义上传文件。差的做法是传递名字。
// 例如这样没有任何校验。
$file_name = $_FILES['file']['name'];
// 上传文件
$s3->putObjectFile(
$_FILES['file']['tmp_name'],
$bucket,
$file_name,
S3::ACL_PUBLIC_READ
);
$url = 'http://'.$bucket.'.s3.amazonaws.com/'.$file_name;
4.3.3　Azure Blob Service上的Node.js
像亚马逊一样，微软Blob服务也有支持Ruby、Java、.NET、Python、PHP以及移动电话的
库。下面举例说明Azure Blob如何轻松集成到Node.js应用中。同样，这段代码实际无法工作，
想要获得完整的代码以及更详细的使用说明需要访问微软的Azure网站
（http://www.windowsazure.com/en-us/develop/）。不管怎么样，举例的目的是，一旦将库加载到
我们的应用之后，使用就很简单：
// 通过npm安装Azure可以获得Azure节点
var azure = require('azure');
// 注册了blob服务之后，Azure可以给予授权证书
//最佳实践是将这些环境变量存储在PaaS上
//它们被称为AZURE_STORAGE_ACCOUNT和AZURE_STORAGE_ACCESS_KEY
//用服务和容器收集资产
var containerName = "myPaaSContainer";
var blobService = azure.createBlobService();
var container = blobService.createContainerIfNotExists(
containerName,
function(error){
if(!error){
// 容器存在并且是私有的
}
}
);
// 上传对象的名字
var blobName = "myimage";
// 文件名,多半是上传的临时文件
var fileName = "/path/to/myimage.jpeg";
var blob = blobService.createBlockBlobFromFile(
containerName,
blobName,
fileName,
function(error){
if(!error){
//文件被上传
}
}
);
var url =
"http://" + AZURE_STORAGE_ACCOUNT + ".blob.core.windows.net/" +
containerName + "/" + blobName;
4.3.4　Rackspace云文件中Ruby编写的常用资产托管功能
如果将大二进制对象存储功能融合到应用中，开发者通常要重复各种功能，例如上传文
件并返回URL以存储在数据库里。想要获得最大的可移植性，通常会在这些经常使用的代码上
增加一个抽象层。这样，如果开发者将来想要使用不同的对象存储供应商，只需要修改一个地
方就可以了。
如果使用面向对象语言，开发者会将这些功能安排到一个类里，或者创建一些全局性的
基础函数。
下面这个简单的类样例是用面向对象Ruby编写的。这里面包含了基于Rackspace云文件
（http://www.rackspace.com/cloud/files）的一些基本逻辑，但它可以很容易被移植到S3、Azure
Blob或者其他任何对象存储上。
有一些库，例如Fog（http://fog.io/storage），已经在其中封装了这些逻辑：
// Usage: o = ObjectStorage.new(container_name)
// o.upload(file, blob_name)
// return o.url
class ObjectStorage
def initialize(name)
@@connection ||= CloudFiles::Connection.new(
:username => ENV["USERNAME"],
:api_key => ENV["API_KEY"]
)
　@container = @@connection.container(name)
end
def upload(file, blob_name)
@object = @container.create_object(blob_name, false)
@object.write(file)
end
def url
@object.public_url
end
end
4.3.5　运用插件上传
当使用内容管理系统（CMS）时，处理过程则不一样。例如WordPress、Drupal和Joomla这些
系统都有插件。开发者可以安装插件，直接跟S3之类的blob服务绑定，从而不需要重写代码。
插件上传机制直接将文件以对象存储方式存放并返回一个URL链接。这种方式缩减了博客或
者CMS加载时间。更好的是，它可以让博客更易于扩展，从而可以添加更多实例。当负载均衡
到一个没有上传内容的应用实例上时，也不会遇到可怕的404错误。
针对当下最流行的一些内容管理系统，下面给出了一个推荐的、可以立刻上手的插件清
单。这些链接提供了最新编码和文档，开发者可以快速简单地整合到自己应用中。
WordPress插件
·UpdraftPlus Backup（http://wordpress.org/extend/plugins/updraftplus/）
·CDN Sync Tool（http://wordpress.org/extend/plugins/cdn-sync-tool/）
·Amazon S3Uploads（http://bit.ly/130xAoz）
Drupal模块
·Storage API（http://drupal.org/project/storage-api）
·Amazon S3（http://drupal.org/project/amazon-s3）
·Cloud Files（http://drupal.org/project/cloud-files）
·S3Auto Pushing（http://drupal.org/project/s3autopush）
Joomla！插件
·JA Amazon S3（http://tinynrl.com/ja-amazon-s3）
·jomCDN（http://tinynrl.com/jomcdn）
4.4　会话管理
当在PaaS上扩展应用时需要慎重思考会话管理工作。除非另行设置，否则会话通常缺省
存放在硬盘上的某个临时文件里。如果应用运行在单服务器上，这种机制很好，但在PaaS上很
容易启动多个应用实例，这意味着应用会在多个不同服务器上运行。对应用的使用者来说，他
们的登录就会被无缘无故地随意注销掉。
会话被创建时，有时候可能系统自动创建（例如，在PHP和Rails代码中），会随机产生一个
惟一的令牌。为了阐述方便，我们将令牌定义为XYZTOKEN并且存放在cookie
MYAPP_SESSION_ID里。PHP应用自动去寻找名称为MYAPP_SESSION_ID的cookie，如果能找
到，应用根据拿到的令牌值去寻找对应的文件。同样为了简化起见，我们假定/tmp目录下有一
个phpsessions目录，令牌是简单的一对一关系。这个用户相关的所有数据都以hash方式保存
在/tmp/phpsessions/XYZTOKEN文件中。与实际情况相比，这个简化例子存在一定风险，但却
能很好地说明整个应用过程。
如果应用需要运行在很多不同服务器上，这些服务器上的文件系统会不同。因此，开发者
需要采用不同的方式存放会话数据。
在PaaS上有三种典型的方式存放会话数据。每种会话管理也都是有利有弊的：
加密会话cookie
·范例：Rails的默认机制，它的插件适用很多其他框架
·优点：速度快而且不需要运行其他服务
·缺点：可以存储的数据量有限，不支持所有网页框架
NoSQL会话存储
·范例：分布式缓存系统memcached，MongoDB
·优点：快速、数据存放无限量、支持大部分框架
·缺点：需要运行专门针对会话管理的服务
SQL会话存储
·范例：MySQL，PostgreSQL
·优点：可以充分运用应用程序中已经使用的SQL数据库
·缺点：速度比另外两种方式慢
有很多不同的方法来实现这些会话管理工具。但这很大程度上取决于开发者采用的技术
和框架结构。
4.4.1　PHP
PHP中，开发者们可以通过session_set_save_handler（）函数（http://bit.ly/ibQzTSy），使用任
何技术重写会话处理器。如果采用Zend框架，开发者可以通过
Zend_Session_SaveHandler_DbTable（http://bit.ly/laxFE5B）轻松跟MySQL数据库创建连接会话。
其他PHP框架也嵌入类似功能，或者开发者可以自己写代码来轻松实现会话管理。下面这段取
自PHP文档的、有注释的代码说明了如何将会话写入文件中：
<?php
class MySessionHandler implements SessionHandlerInterface
{
private $savePath; // 存放会话的地方
// 初始化会话对象并创建目录
// 会话文件需要时用
public function open($savePath, $sessionName)
{
$this->savePath = $savePath;
if (!is_dir($this->savePath)) {
mkdir($this->savePath, 0777);
}
return true;
}
//结束会话时什么都不用做
// 对象
public function close()
{
return true;
}
//将数据返回给输入的会话id($id)
//存放在磁盘上的会话文件内
public function read($id)
{
return (string) @file_get_contents("$this->savePath/sess_$id");
}
// 将会话数据写入会话文件内
public function write($id, $data)
{
return file_put_contents("$this->savePath/sess_$id", $data) === false ?
false : true;
}
// when you want to delete a session, delete the
// 包含数据的会话文件
public function destroy($id)
{
$file = "$this->savePath/sess_$id";
if (file_exists($file)) {
unlink($file);
}
return true;
}
// 对于超过给定时间的会话管理对象
//进行垃圾回收
public function gc($maxlifetime)
{
foreach (glob("$this->savePath/sess_*") as $file) {
if (filemtime($file) + $maxlifetime < time() && file_exists($file)) {
unlink($file);
}
}
return true;
}
} $
handler =
new MySessionHandler();
session_set_save_handler($handler, true);
session_start();
// 从$_SESSION 中通过键值设置并检索值
4.4.2　Node.js
在Node.js中，提供很多npm模块实现cookies加密。如果开发使用连接中间件，则可以采用
galette和cookie-sessions两个插件实现cookies加密功能。
4.4.3　Ruby
在Rails中，缺省会话管理机制是加密cookie，但如果开发者想要改用Mongo或者MySQL服
务只需要编辑config/initializers/session_store.rb文件。
4.4.4　Java
在Java中，Tomcat内置了群集功能，可以自动将每个会话复制到每个Tomcat实例上。这种
机制不需要对代码进行重大修改。然而，缺点是这种管理和维护会话复制的方式会导致网络
负载过大，Tomcat的这种特性在负载均衡时需要粘滞会话，而这并非每个PaaS都支持。如果想
要用Java完成cookies加密，可以查看Marc Fasel著的《Cookie应用中的会话管理》（Session In
Cookie application，https://github.com/marcfasel/sessionInCookie）以及相关的博客帖子
（http://bit.ly/197Y1A2），那里会有更详细的说明。
4.5　缓存
缓存是影响网页架构可扩展性的一个重要部分，而且形式多样。
一种比较原始但却很高效的缓存方式是获取服务器端产生的动态内容，以文件形式下载
到磁盘，以后就从磁盘上调取该文件。缓存到磁盘可以将每个请求的CPU资源消耗最小化，能
保证CPU高速运转，它可以大幅提升每秒钟网站所能接受的请求数。缓存数据也能存放在
RAM或NoSQL数据库中，这样可以进一步减少处理的延迟并加强应用实例的可扩展性。
还有一种缓存技术是将产生的代码片段存放在RAM或NoSQL数据库缓存中。如果使用得
当，这种技术可以创建一个高速强大的动静态混合体，大幅度提升网站速度。
无论开发者使用何种语言，通常都能具备代码预编译功能。PHP可以选择APC或者字节码
生成器解决方案，通过预解析、预先理解将要运行的代码从而提高应用的运行性能。在Java
中，编译是必经之路，所以上面的方法不适用，但很多动态语言（例如Python和Node.js）中，采
用预编译缓存会带来附加的价值。
4.5.1　片段填充
依据不同的具体情况，在应用迁移过程中，缓存技术可能不需要从遗留应用上迁移到基
于云的PaaS上。为什么？因为一般缓存的工作模式是这样的，即如果一个HTML某部分丢失
——磁盘上没有保存，或者不在它应该在的地方——系统会再产生相应的内容作进行补偿。
例如，我们有3个不同实例并且只有一个磁盘上部署缓存，当用户碰巧访问的是还没有缓
存的那个实例时，系统会生成缓存代码并保存到第二个实例上，下次在第二个实例上有请求
时系统无需再次生成。
这种机制的最大问题是当重新装载缓存页面时，用户看到的内容会不同。如果一个实例
上有一个一周前的备份，第二个实例上是三天前的，而还有一个是最新备份，每次重新装载展
示的数据都会不一样。
但也不总是出现这种问题，因此从缓存角度看，迁移遗留应用并不一定导致较差的用户
体验。但是，存放数据的磁盘有可能出问题，又或者不同磁盘上的数据不一致。某一个服务器
上缓存的数据可能与其他服务器上的不一致，从而导致用户不一致的用户体验。
将遗留应用迁移到PaaS上时，开发者可以利用这一机会来实施最佳实践，即采用SQL或
NoSQL数据库替代磁盘存放数据，从而创建应用的中心缓存存储。因此，取代磁盘访问，开发
者可以使用分布式缓存、Redis、MongoDB或CouchDB等技术。有些情况下，我们可能会将数据
直接存放在MySQL或PostreSQL之类的SQL数据库中。
选择MySQL和PostgreSQL，优点是与数据库的连接已经建好而且不需要依赖其他服务。因
此如果开发者不使用分布式缓存或者NoSQL服务，鉴于应用里已经在用MySQL数据库，直接
使用它更有意义。然而，当开发者越来越看重性能和可扩展性时，使用分布式缓存和NoSQL的
优势就体现了：大多数情况下可以非常快的获取数据，尤其使用分布式缓存。使用NoSQL，开
发者将数据存放在RAM，这是获取数据最快的地方。在大多数SQL数据库中，频繁使用的数据
也在一定程度上被存放在RAM中。如果没达到RAM中存放数据的极限时，我们可能看不出分
布式缓存和MySQL质的区别。然而，随着数据库的成长，这终将成为一个瓶颈。
使用PaaS的最大好处之一就是能非常简单地向应用上添加更多服务。例如，由于不想运
行、扩展数据库，开发者不敢使用MongoDB，PaaS会帮你完成这些，因此开发者可以更灵活地
去尝试以前望而却步的服务。
4.5.2　PHP中的分布式缓存
客户端的缓存整合通常很简单。使用PHP，如果是在Ubuntu上，开发者所要做的一切就是
执行sudo apt-get install php5-memcached语句在客户端安装PHP分布式库。然后就能使用下面的
编码获取并设置分布式键值存储中的键/值：
<?php
$cache = new Memcached();
// 分布式机制支持多服务器，
// 最好将名字保存在环境变量里
$cache->addServer(
getenv("MEMCACHED_SERVER"), getenv("MEMCACHED_PORT")
);
// 配置
$cache->set("foo", "Hello World!");
// 获取
$cache->get("foo"),
?>
4.5.3　Node.js上MongoDB的缓存机制
缓存在MongoDB之类NoSQL数据库上，通常和使用分布式RAM哈希系统一样，操作简
单。这是因为从本质上来说它们都是基于键/值存储的，缓存采用比较原始的分布式键/值存
储。（事实上不完全正确，尤其当键/值组要过期时，但大部分情况下可以认为是基本一样。）
Node.js上有一个称为mongodb的npm模块支持mongodb客户端。只需要执行npm install
mongodb就能安装：
// 通过环境变量传递连接字符串
var mongourl = process.env.ENV_VARIABLE["mongourl"];
require('mongodb').connect(mongourl, function(err, cache) {
var collection = db.collection('cache');
// 设置
collection.insert({
key: "foo",
value: "Hello World!"
});
// 获取
collection.findOne({ key: "foo" },
function(err, item) {}
);
});
4.5.4　常用Redis Ruby缓存功能
当在应用中融入缓存功能时，开发者经常需要重复执行各种函数，例如获取和设置键/值
组。通常对这些常用代码增加一层抽象层很有意义，最大化可移植性。这样，未来想要使用不
同的对象存储供应商，只需要在主程序里修改一个地方就行了。
如果使用面向对象语言开发，我们可以将这些功能组合到一个类中，或者可以创建一些
基础全局性函数。
下面示范的简单类例子是用面向对象语言Ruby编写的。它包含基于Redis工作的一些基础
逻辑，能轻松移植到MySQL、分布式缓存或者任何其他使用缓存的技术：
gem "redis"
require "redis"
// Usage: cache = ObjectCache.new
// cache["key"] = "value"
// return cache["key"]
class ObjectCache
def initialize
@connection = Redis.new(
ENV["REDIS_SERVER"]
)
end
def [](key)
@connection[key]
end
def []=(key, value)
@connection[key] = value
end
end
4.6　异步处理
长时间运行任务——占用大量CPU、RAM或处理资源的任务——应该被设计成后台运行
才不会影响用户在网站上的体验。平台即服务供应商经常会杀掉长时间运行的、面向Web的进
程。这意味着将遗留应用简单迁移到云上的时候，异步处理也很重要，而不仅仅是最佳实践。
4.6.1　存放数据服务
举个例子。这里有一长串数据，可能是RSS URLs。这种数据通过调用很多高延迟API来处
理（周期性轮询各种RSS资源）。因为这种数据需要很快展现，开发者不愿意在当用户查看数
据，而系统正在实时处理请求时收集它。
另一个例子是处理图像或者视频。当有人上传图片，应用想要调整其尺寸、压缩容量或者
许多其他跟数量相关的工作。根据图片的尺寸，处理它可能需要大量的RAM、CPU和时间。处
理过程需要很长时间（几十分钟甚至几小时），这样的实时处理，前端用户是无法忍受的。处理
图片和视频应该异步处理并且在处理结束时推送给用户。
实现方法是异步后台收集和运算，这样能有足够的时间和CPU资源。数据可以存放在数据
库或者缓存机制中。一旦存放，Web前端应用能快速直接实时访问。
4.6.2　如何创建异步过程
设立长时间事务的常用技术实际上很简单。下面是一段伪代码：
开始的时候：
for each task in tasks
do
//可能要持续一会儿
process the task
end
然后：
for each task in tasks
do
// 只需要一毫秒
queue task for processing
end
处理代码类似这样：
loop
do
grab task from queue
process the task
end
4.6.3　更多后台任务的高级调度技术
随着开发者越来越熟悉如何将后台任务整合到应用中，他们会想要编码更漂亮。开发者
可以融入开源系统，例如Python的Celery（http://www.celeryproject.org），它提供基于分布式消
息传递的异步任务队列，而且也支持特定时刻的调度任务。Celery采用RabbitMQ、Redis、
Beanstalk、MongoDB或CouchDB作为后端，支撑它的服务。
Ruby语言中也有一个类似的项目，即基于Redis（https://github.com/blog/542-introducingresque）
的Resque（https://github.com/defunkt/resque）。这些项目使得对用户队列状态及运行情况
的监控更为灵活，而这在应用不断扩展时很关键。
除了开源项目，也有一些第三方服务后台运行特定任务，例如Iron.io的IronWorker。Ruby、
Python、PHP、Node.js、Go、Java和.NET都有IronWorker（http://www.iron.ip/worker）的库，它不需
要整合任何服务，而像Celery就需要RabbitMQ或Redis之类的服务。它是个全程管理服务，接
收、并在云上的服务器运行代码，而这些服务器则由Iron.io管理。
4.7　SQL
当我们正在处理遗留应用并想要迁移到PaaS上时，一定要注意选用平台所能支持SQL服
务的优点和局限性。
存储过程的困境
在迁移遗留系统的数据库时“成功啦”通常指的存储过程。它们在遗留应用里普遍使用存
储过程上的问题。然而，很多平台上，托管数据库不太适用存储过程，很多PaaS供应商，完全
抵制，这对遗留应用来说是个问题。使用存储过程并不是最佳实施，尽管以前会这样使用它
们，现在的编程方法不建议这种用法。
存储过程是存放在数据库里，当执行SQL请求时优先执行的函数。存储过程的一个小例子
可能是合并数据库上两列，开发者无需编辑自己的代码，直接调用那个存储过程就可以获得
两列的合并结果。
当然，当数据进入数据库时，相比编码而言，存储过程的处理更复杂且能抵消掉数据进入
数据库时运算的工作量。
存储过程的一个大问题是它们是一次性创建，难以记忆和跟踪监控。使用哪个存储过程
并进行维护很难记录，这使得代码调试、测试都很难。当开发者使用本地数据库——除了QA
版本、开发版本，还有产品版本——想要维护、分配，以及在这些版本之间转化存储过程是非
常困难的。单元测试的兴起是对存储过程的致命一击。存储过程无法在多个数据库上简单高
效地运行单元测试，这使得它们不再流行。
如果应用里的存储过程无法去除，我们也是有解决方案的。PaaS供应商开始寻找第三方
的专用数据库，有些供应商自己就提供专用数据库。现在有供应商将MySQL即服务作为专用
基础服务，包括Xeround和ClearDB。甚至亚马逊也有MySQL服务称为RDS，那是个专用、托管
的MySQL环境。通常，当开发者有专用MySQL实例时，是可以存放那些存储过程的。
因此，如果开发者无法避开存储过程的困境，仍然有办法将遗留应用迁移到云上。但是解
决方法的代价很高，而且随着应用的扩展，安装从数据库并确保多个数据库之间的数据一致
性将变得非常困难。
4.8　NoSQL
对遗留应用而言，NoSQL更容易迁移至PaaS，因为它没有存储过程的概念。这样几乎没有
什么开销。PaaS平台上大部分NoSQL服务使用类似的接口，即便开发者没接触过的接口使用
起来也非常简单。不管键/值存储是跟分布式缓存一样简单，还是跟Riak一样健壮，它在云环境
里的工作方式通常都是相似的。事实上，很多NoSQL选项很有用，可以协助资产托管、缓存，
甚至异步处理。充分利用键/值存储对遗留应用迁移至PaaS很有帮助。
下面列举了开发者可以选择的NoSQL数据库列表：
·MongoDB
·CouchDB
·Redis
·Cassandra
·Riak
·HBase
·Cassandra
·Amazon SimpleDB
·Amazon DynamoDB
·Azure Table Storage
4.9　各种陷阱
当开发者们将遗留应用迁移至PaaS时必须考虑清楚，如果磁盘坏了或者任何一个服务器
死机时，应用该如何存续，用户体验会怎样。
PaaS可以实现对服务的管理、负载均衡、网络故障以及心跳的监控。除了遗留代码的重
写，它能帮开发者做很多事。因为PaaS不知道这些代码跟写磁盘之间的关系。很多时候开发者
忘记的库里的几小段代码里，有关于存储信息的假定条件。因此尝试将应用迁移到PaaS，经常
会像大海捞针般难。但一旦完成了迁移，则受益无穷：使得我们的应用遵循独立于云标准的标
准，这被整个业界公认为最佳做法。
在构建应用的原型或者早期阶段，可能从来不会考虑到有一天需要将应用迁移到PaaS
上。这就引出了另外一个值得我们考虑的问题。
4.9.1　优化陷阱
编写或者重写代码时最容易犯的错是不成熟优化：创建自己认为可能会需要的功能或者
提前给应用做优化。然而，我们在这章里探讨了这么多并未涉及不成熟优化的内容。它们是最
佳实践的影响因素之一，因为随着应用开始扩展都会考虑使用PaaS。
不成熟的优化对应用扩展而言，可能有作用，也可能毫无作用。这章所讨论的主题都很重
要，当开发者从头开发应用的时候需要考虑这些内容，这样就不会出现到项目后期的时候还
要移植更多的遗留代码。
4.9.2　从头开始
将遗留应用丢弃，直接从新开发，是不是会更好呢？
看具体情况而言。不同的应用、开发者、团队的注意事项各不相同。必定会有比重新编写
代码更有意义的情况。同样也有开发者不能这么做的情况，应用可能是基于WordPress或
Drupal系统的。遗留代码耦合度太高以至于不能被丢弃并重新开发。
也有一种情况是应用成长过快以至于不可能丢弃所有代码。其他项目可能需要其部分代
码，拆分并创建更小的应用实现服务——例如文件上传——不依赖于主程序。同样这都是看
具体情况而定的。
4.9.3　遗留应用的最后提醒
查看所有应用代码相关的地方，直接依赖的磁盘或者任何单个的服务器。要注意将多实
例上需要的数据存放在RAM上，对有可能对用户体验造成负面影响的地方进行审计。
第5章　在PaaS上开发新应用程序
遗留Web应用通常都比较巨大而且难以扩展。正如我们在第4章中所看到的那样，可以将
遗留应用迁移到平台即服务，但是由于架构完全不同，所以整个过程可能是非常繁琐的。只有
当从头开始开发新的应用程序的时候，我们才能真正地领略到平台即服务的魅力所在。
在我们进一步讨论如何在PaaS上创建新应用程序之前，先检视一下旧应用程序的庞大而
缺乏灵活性的特点，也许会有所帮助。
5.1　分解庞然大物
巨型代码是指持续不断地向一个应用程序中添加功能，不停地增加新的特性如搜索功
能、账号管理、博客发布等。这就像一头极具破坏性的怪兽，同时也是一锅大杂烩。会产生一
些问题，如内存泄漏，以及应用程序所消耗的RAM越来越多。
调试这类应用程序就如同试图在迷宫中寻找出路那般困难重重。但是，如果每个应用程
序的组件都是独立的，比如搜索组件与博客发布组件相互分离，而后者又与用户界面组件相
分离，等等。如此，每个单独的组件就可以独立地运行和扩展，从而获得更多的灵活性。例如，
假设我们的服务更多地依赖于搜索功能而不是用户注册和管理，一方面，我们就可以对搜索
组件进行更多的扩展，给它分配更多的资源，另一方面，用户组件就可以维持在较小的规模。
但是，对于巨型应用程序来说，所有的组件都是这个巨型程序的一部分。
在怀疑内存泄漏时，即使可以通过某些手段对应用的组件进行隔离，例如将这些请求重
新转发到一个单独的进程池，通常也无济于事。其效果如同在干腐的木地板上铺上地毯一样，
问题不但没有得到解决，反而会变得更坏。
作为最佳编程实践之一，在平台即服务上实现应用程序时，就必须考虑将每个数据源以
及应用程序中的每个专业区域作为一个小的，独立运行的服务。这样，当把巨型应用程序分解
为这些相互交互并且联系的比较小的部分之后，PaaS的好处很快就体现了出来。
小型应用程序可以一次性将某件事情做好，因此就更容易扩展，这是因为可以针对特定
的工具选择不同的后台技术。而在巨型应用中，我们只能在其中使用一种后台技术，因为这个
技术可能被使用在所有的地方。比如，在应用中使用了MySQL，而Redis可能会是更好的选择。
或者使用了PostgreSQL，而MongoDB数据库可能更合理。
同时，调试小型应用程序也更加容易些。每个应用中所包含的代码越多，应用之间的相互
依赖就越强，由于要测试越来越多的边界条件，因此，测试起来也就更难。
对于一个专业开发者来说，最佳实践之一就是通过单元测试，功能测试，集成测试，持续
的测试代码。相对于高耦合的巨型应用程序来说，小型的基于服务的应用程序更容易做到这
一点。采用更小的服务，我们可以获得那些更容易被大规模和独立的测试的应用组件。
回顾一下应用编程的历史，可以发现其中不乏一些巨型应用，它们被构建了之后，再被分
拆，有时候这种情况会一而再，再而三的发生。Twitter在2006年刚起步的时候就是相对比较巨
型的一个Rails程序。在2010年，它被解耦为应用编程接口（API），通过这个API给一个更为轻量
级的JavaScript前端（http://tinyurl.com/twitter-decoupled）提供服务。从此以后，就以一种面向服
务的方式增加功能，同时也融入了其他一些技术以建立一个高度分布式、可伸缩的系统，例如
Scala、Python、甚至Drupal（https://dev.twitter.com/opensource/thanks）。在高伸缩性博客
（http://tinyurl.com/making-twitter-fast）上，我们可以了解到Twitter分解巨型应用的所有冒险历
程。最终，Twitter采用一个更为动态的前端替换了其基于JavaScript的API前端。但是，这一动
态前端依然使用相同的底层分布式API。
如今，类似的故事依然每天发生在大大小小的公司。开发者开始从这些大型的服务中学
习到经验教训，并且开始总结出一些关于大型服务的最佳实践。在此基础上，开始在开发速度
以及在适应扩展需求的总体架构之间进行权衡。本质上说，这是基于新技术的面向服务架构
（SOA）在Web应用上的一次复兴，以便更容易进行构建和维护。同时，标准技术（例如REST）也
让服务更统一和易维护。
独立性思考
考虑一个对于大型企业，金融公司或者政府机构来说很常见的场景：正在创建一个应用程
序，在这个程序中有一个受数据约束的部分，这个部分只能在内部运行，而且通常只是程序中
很小的一个部分，差不多占5%~10%左右。
如果把这个程序构建的非常巨大，由于数据约束，那么整个程序可能都只能在内部运行。
但是，如果将其构建成分布式系统，通过很多API往一个轻量级的JavaScript的前端（或者更为
简单地使用其他服务API的动态前端）填充数据，那么就可以将90%的应用部分安全的托管在
公共云上。所有不需要与敏感数据交互的常规部分都可以运行在云端的更为便宜且通用的硬
件上。
我们已经看到了很多类似的现代面向服务、API驱动的架构的成功例子。我们已经讨论过
Twitter，而且Gmail也采用了一个基于API驱动的客户端的方式，将所有需要与邮件打交道的
API放在一起，通过JavaScript前端进行交互。Apple公司也采用了与MobileMe类似的方式：后
端都是简单的API，而前端则用一个功能比较丰富的客户端程序实时处理大部分逻辑。这样就
具备了更多的灵活性、扩展性以及前瞻性，并且让最终的程序更好，更易于维护。
在平台即服务上尤其适合采用这一方法以构建很多小的服务。实际上，这也是采用PaaS
的最佳实践之一。创建独立的服务并通过前端进行整合，这不仅是应用在Web和移动应用开发
上的一种现代方法，而且在决定如何融入平台即服务策略的时候也必须进行考虑。
5.2　将API应用于移动开发
在应用开发过程中的分解和服务化背后的驱动因素之一——如今也同样适用于另外一个
最大的，更具颠覆性的技术——那就是移动技术。移动应用的世界快速增长，已经成为了我们
生活必不可少的一部分。在2012年的时候，在应用商店的各类本地应用的累计下载量已经超
过540亿，而且每月新增200万下载量。有人估计，这仅仅占整个移动应用市场的十分之一。
在一个具有5000亿移动应用的世界里，用以支持这些应用的系统的计算能力和编程范式
也得与时俱进。大多数移动应用都依靠后端服务来进行用户注册、共享照片和新闻信息、提供
广告以及提供其他很多动态特性。如果没有后端的API基础设施提供服务，诸如Instagram，
Pinterest，甚至Facebook之类的应用将不再有任何存在的意义。
最近，在移动应用开发领域一个颇为成功的故事就是Instagram（http://instageam.com）。凭
着13名员工，创始人通过这款移动应用创造了一个价值数十亿美元的公司。那么这13个员工
到底干了哪些编程工作呢？Instagram的本地应用端并不是世界上最复杂的技术。构建这些本
地移动应用的后端服务以支持百万级的并发用户才是异常复杂的工作。因此，构建移动应用
底层基础设施，以收集和共享信息，并处理照片才是一项非常巨大的挑战。这个团队采用亚马
逊的云完成了这一项任务。如果要了解更多的信息，可以参考高伸缩性博客上的文
章“Facebook花费十亿美金购买Instagram架构”（http://hit.ly/laYFKgv）。
Instagram的成功给了现代应用开发者一定的启示，不论这些开发者来自大型企业还是小
型的创业公司，让他们能够更好地将应用呈现给上百万，甚至千万的智能手机用户。但是，开
发者依然需要为管理和处理后台的约束做好准备，例如服务需要面对突然增长的用户访问。
这些约束让所构建的API服务必须具备一定的可伸缩性。
这些服务的魅力在于所有的这些API，经过仔细思考和良好的构建之后，可以为现代Web
应用程序提供服务。也就是说，如果以一种面向服务的世界构建应用的话，这些服务可以同时
成为移动应用和Web应用的后端。如果在开始构建Web应用的时候就考虑到了这一点，那么当
需要增加移动应用支持的时候，一切都已经就绪。同样的数据源已经为移动应用做好了准备。
如果已经有了一个移动应用程序，但是需要一个Web应用，那么采用这一技术也是一种非常棒
的途径。
5.3　JSON和REST的出现
在面向服务架构的早期先驱中，诸如SOAP、XML-PRC以及WSDL是通过API来结构化数
据和通讯的标准。这些都是重量级、且缺乏灵活性的标准，通常非常难以运用。
随着面向对象架构的再次复兴，出现了一些更新，同时也更敏捷、更轻量的概念，比如
JSON和REST。这些新的概念在保持敏捷性和速度的同时，也保留了松耦合分布式系统的好
处。
5.3.1　JSON简介
JSON（JavaScript Object Notation的简称）是作为在API服务内部传输数据的标准出现的，
它可以作为替换XML的备选方案之一。JSON应用极为广泛，包括Gmail、MobileMe、iCloud、
Twitter、LinedIn，以及几乎我们可能访问的每一个主流网站。JSON有如此大的影响力的原因之
一就是对于Web前端来说，通过JavaScript处理JSON数据非常简单，自然而然，JSON对于本地
移动客户端也可以提供非常好的支持。借助于那些可以应用在移动和Web应用编程解析JSON
数据的库，JSON理所当然地成为现代应用程序中产生和展现数据的标准。
无论对于计算机还是对于人们来说，JSON的数据模式都是比较易于理解的。以下就是一
个例子：
{
"id": 1,
"name": "Programming for PaaS",
"price": 123,
"tags": ["PaaS", "Programming"]
}
JSON另外一个非常不错的优点在于，非常易于被浏览器所解析。这就让它成为Ajax编程
中所使用的非常优秀的数据格式。从以下的例子中我们可以看到运行于浏览器中的本地
JavaScript客户端，或者任何基于Node.js的应用解析JSON数据是如何的简单：
var object = eval(text);
这也许不是最安全的技术（在执行之前对文本进行验证总是最佳实践之一）。但是，它给
我们展示了JSON数据格式的强大之处。
5.3.2　REST简介
REST（Representational State Transfer的简称）是诸如Web应用之类的分布式系统的一种架
构模式（架构风格）。通过复用HTTP的基本操作，如GET、POST、PUT以及DELETE，REST已经
成为了一种主流服务设计模型。由于采用了简单的HTTP命令，REST就可以比基于SOAP的服
务占用更少的带宽，因为SOAP需要处理很长的头以及繁琐的XML解析。
REST背后的基本原则就是通过提供一个共享的网络词汇，以一种标准的、可预测的格式
来传输资源。这是什么意思呢？让我们来看一个基于REST的用于管理用户数据的JSON服务：
GET
列出资源（可以被缓存）
·http://example.com/users[1]
　　 Header:
　　 none
　　 Response:
　　 [
　　 {'id': 123,
　　 'name': 'a'},
　　 {'id': 124,
　　 'name': 'b'}
　　 ]
·http://example.com/users/123
　　 Header:
　　 none
　　 Response:
　　 {'id': 123,
　　 'name': 'a'}
·http://example.com/users?name=b[2]
　　 Header:
　　 none
　　 Response:
　　 [
　　 {'id': 124,
　　 'name': 'b'}
　　 ]
PUT
更新资源（不可缓存）
·http://example.com/users
Header:
　　 [
　　 {'id': 123,
　　 'name': 'x'},
　　 {'id': 124,
　　 'name': 'y'}
　 ]
　　 Response:
　　 200 OK
·http://example.com/users/123
　　 Header:
　　 {'id': 123,
　　 'name': 'x'}
　　 Response:
　　 200 OK
·http://example.com/users?name=b
　　 Header:
　　 [
　　 {'id': 124,
　　 'name': 'y'}
　　 ]
　　 Response:
　　 200 OK
POST
创建新资源（不可缓存）
·http://example.com/users
　　 Header:
　　 {'id': 125,
　　 'name': 'c'}
　　 Response:
　　 200 OK
·http://example.com/users/123
Not used
·http://example.com/users?name=b
创建新资源的时候不需要查询字符串
DELETE
删除资源（不可缓存）
·http://example.com/users
　　 Header:
　　 None
　　 Response:
　　 200 OK
　　 Note:
　　 Deleted all users
·http://example.com/users/123
　　 Header:
　　 None
　　 Response:
　　 200 OK
　　 Note:
　　 Deleted only user 123
·http://example.com/users?name=b
　　 Header:
　　 None
　　 Response:
　　 200 OK
　　 Note:
　　 Deleted all users named b
采用REST方式，对服务的创建和管理就变得可以预测并且更为简单直接。对任何基于
REST的服务的创建和扩展通常都不会再那么的充满挑战。
例如，如果我们的服务在后面若干年都不大可能要处理100000行数据的话，那么就没有
必要担心MySQL或者PostgreSQL中的表没法应付，从而需要扩展，因为这些传统的SQL表可以
轻而易举地在一台服务器上处理百万，甚至千万行数据。
但是，如果所要处理的数据将会达到100000000行，那么可能就需要考虑更适合高度分布
式增长环境下的数据库，例如Riak或者CouchDB。
5.3.3　元服务简介
元服务是一种基于REST的应用程序，用于为数据的集合提供服务。
详细来说，元服务就是一个轻量级的应用，它调用核心的服务（例如MySQL、MongoDB、
Redis、memcached，等等），然后产生REST的应用编程接口（API），这些接口通常用于为JSON
或者XML序列化数据提供服务。
一个元服务就像一个用REST封装的核心服务，具有非常有限的应用逻辑，这些应用逻辑
通常只限于该元服务所提供的特定功能。比如用户注册元服务、评论服务、消息服务以及一个
微博服务。有时候，同一个数据库可以服务于不同的元服务，而另外一些场合下，每个元服务
都可能有自己的数据库和核心服务。
通常，如果不采用针对数据源构建元服务，我们需要创建很多代码去完成REST的功能，
而且将很多服务混合在一切，逻辑相互交叉，结果就是动态生成的HTML、CSS以及JavaScript
的混合在一起的大杂烩，而不是生成简单的JSON序列化对象。当需要替换某个组件时，就会
发现非常困难，甚至没有这个可能。在希望扩展某些组件的时候，就会发现组件之间盘根错
节。一个只有100条记录，需要频繁被访问的表，和一个可能有100000000条记录，不需要被频
繁访问但是需要快速索引的表在一个数据库中。对于采用传统方式扩展Web应用来说，这将是
一个噩梦。事实上，已经有成百上千的开发者实践过这一方法。这些开发者最终只有把应用分
解为元服务。因此，为什么不在开始的时候就采用元服务呢？
元服务是在核心服务的概念上构建的。因此，必须受这些服务驱动，例如MySQL、
MongoDB以及PostgreSQL。但是，元服务采用那些可以直接访问驱动和服务的轻量级的API进
行封装。相对于HTML展现，或者直接发布给用户的前端应用来说，这些通常比较简单。元服
务只是简单的生成JSON：在现有服务的基础上序列化数据结构。因此，一个元服务提供序列化
数据给客户前端应用，通常采用诸如JSON的序列化格式。这些元服务已经成为现代可伸缩
Web架构的构建模块。
对于几乎所有的语言，都有其相应的框架可以快速地生成基于REST的应用程序。在第10
章中给出了一个完整的列表，覆盖了相当宽泛的语言类别。因此，不管采用什么语言，总能够
找到恰当的REST框架。
这些框架共同的特征是，它们简化了基于REST的路由URL的开发，并且给响应每个HTTP
动词（GET、PUT、POST、DELETE）的代码提供了数据结构。
[1] limit和offset可以作为查询字符串发送并且有助于记录大量收集。例如：?
limit=2$offset=122。
[2] 你可以RESTfully地完成搜索，也可以添加limit和offset。
5.4　使用基于REST的元服务
为什么采用元服务？因为元服务可以很容易的被创建并且调用。元服务不需要巨型应用
中那么多的逻辑，因此可以更快更好地完成工作。
一旦创建了元服务，就可以以多种不同的方式访问这些元服务。可以通过移动客户端或
者Web应用来访问，也可以在前端采用不同的技术将这些服务组合在一起协同工作。
5.4.1　应用客户端
每种编程语言都有很多的库可以访问元服务。只需要把一个基于REST的URL提供给这个
库，它就可以给调用代码提供相应的结果。这样，我们就可以将多个元服务组合在一个轻量级
的、动态的后端中，给终端用户提供编译完的数据。以下是一个采用Ruby的ActiveResource库
的例子，该例子给我们展示了调用这个库是如此的容易：
class Person < ActiveResource::Base
self.site = ENV["PEOPLE_REST_URL"] // Best Practice
end
ryan = Person.new(
:first => 'Ryan',
:last => 'Daigle'
) ryan.save #
=> true
ryan.id # => 2
Person.exists?(ryan.id) # => true
ryan.exists? # => true
ryan = Person.find(1)
# Resource holding our newly created Person object
ryan.first = 'Rizzle'
ryan.save # => true
ryan.destroy # => true
我们可以看到基于REST的客户端是多么强大。它们可以与MySQL和PostgreSQL一样被调
用，并且服务于不同的应用目的。
5.4.2　移动客户端
这将在第6章中详细讨论。
5.4.3　瘦Web客户端
元服务可以直接在浏览器中调用。实际上，根本不需要任何框架就可以处理一个标准的
基于REST的URL请求。任何基于浏览器的，具备exec（）函数的Ajax调用都可以做到这一点：
var url = "http://example.com/users";
var req = new XMLHttpRequest();
req.onreadystatechange = function() {
if (req.status == 200) {
var json = req.responseText;
// this is not secure, only
// showing this for example
var object = exec(json);
// do something with
// the object...
}
} req.open("GET", url, true);
req.send();
这段代码看起来有些累赘并且难以理解。但是，采用某些现代的JavaScript框架，我们就可
以给任何网站添加这样的功能，即不仅可以自动地调用这些元服务，而且还可以结构化的显
示数据。这些框架包括：
·Backbone（http://backbonejs.org）
·Angular（http://angularjs.org）
·Ember（http://emberjs.org）
·Spine（http://spinejs.org）
·Knockout（http://knockoutjs.org）
至于如何根据实际需要选择恰当的JavaScript框架，可以参考Anderson的博客文章“富
JavaScript应用——七个框架”（Rich JavaScript Applications-the Seven
Frameworks，http://bit.ly/18v52pw）。
5.4.4　胖Web客户端
诸如SproutCore（http://sproutcore.com）和Cappuccino（http://www.capuccino-project.org）之
类的技术令人印象深刻，它们可以作为数据绑定的构建模块。这是一种经过深入思考并且经
过实践检验过的方法，应用在现代桌面环境下开发应用软件，可以包括不同的数据源和数据
绑定。
随着我们的JavaScript前端客户层的功能变得日益丰富，我们可以看到越来越多的数据源
被前端所使用。前端应用通过一种非常动态、展现良好以及结构化的Web界面进行展现。
SproutCore和Cappuccino为我们提供了构建模块，通过一种非常标准的方法将这些基础元
素组合在一起就可以构建现代应用程序，这些应用无论在Web还是在移动客户端上都让人感
觉到类似桌面应用的效果。实际上，SproutCore和Cappuccino优点类似使用苹果公司的Xcode或
者微软公司的Visual Studio。对于一个传统Web开发者来说，如果从来没有创建过桌面或者本
地移动应用，那么这些工具起初的时候看起来就会有些奇怪。可视化的组件都是严格定义好
的，因此，一旦完成了数据源的绑定，一切就神奇地可以工作了。
采用这些技术的一个好处就是一切都是预定好的。它们内置了很多卓越的用户体验，因
此，有些客户端可以被编译为本地移动应用。例如，如果采用Cappuccino开发应用，就可以使
用一些诸如NativeHost的服务，将应用编译为一个在桌面环境下运行的本地应用，而不需要做
任何修改。这就促使我们从跨媒介的角度去思考应用程序的开发。
这些技术的资源很丰富，而且可以得到很好的支持，因此一些大公司也开始使用。苹果公
司就采用SproutCore构建了全部的iCloud的Web应用套件，包括邮件、联系人、日历、笔记、提
醒、搜寻我的电话以及iWork。NPR也创建了一个非常漂亮的、基于Cappuccino的播放器来流式
化其广播内容。每天都有很多新的、采用这些胖客户端界面的例子诞生。
5.5　PaaS的独特贡献
采用元服务开发应用，刚好可以将遗留应用迁移到平台即服务时所遇到的弱点全部抵消
掉。
在开发一个巨型应用时，就得考虑几乎所有的方面，比如程序的哪部分需要使用磁盘，哪
部分导致内存泄漏，哪些代码运行在这些地方。于是，迁移遗留系统就会变得异常复杂，因为
所涉及的组件实在是太多了。
当采用本章中所列出的新式开发方法时，所带来的好处包括构建更加简单、更为轻量级
的后端客户端，这些客户端不再依赖于文件系统，而是更多地依赖于可伸缩性的服务。在应用
的某个部分需要扩展时，可以更为容易的增加新的实例。需要给网站的搜索组件更强的处理
能力吗？专注于搜索元服务即可。
采用这些最佳实践，从头开发一个应用的时候，需要考虑的是每一个组件如何独立的运
行和扩展，而这恰恰是在把遗留应用迁移到平台即服务时所需要解决的问题。事实上，在将遗
留代码向PaaS迁移的时候，最有效的方法就是把应用中的逻辑部分分隔为元服务，并且一部
分一部分地分解应用程序。
5.5.1　四大重要优点
这种新的开发方式在四个重要方面体现出与众不同的优点：敏捷性、面市时间、可伸缩性
以及互操作性。
敏捷性
敏捷性是指能够快速的响应应用的需求，即添加新特性的能力，也指将不再需要的特性
移除到项目之外，同时重新构建特性的能力。基于PaaS，采用面向服务的元服务的开发方式成
倍地提升了敏捷性。
在新增特性或者功能的时候，PaaS提升了敏捷性。这是因为相互独立的团队可以基于这
些元服务独立地开展工作。在需要新增功能的时候，就可以这么做，而不需要去拆解和理解整
个应用程序——这个庞然大物。简而言之，平台即服务可以让我们在应用程序开发的时候变
得更为敏捷。
面市时间
采用这些新技术，可以缩短产品的面市时间。我们可以不用花那么多时间去关心如何维
护和扩展应用，而把更多的时间用于思考如何让所有的组件协同工作。
我们不再把时间花费在如何构建一个庞然大物上。可以构建一个简单的后端原型，确保
它能够正常工作并且可以被前端调用，然后就可以让应用程序启动并且很快的运行起来（相对
于提前构建整个系统来说，这一过程要快得多）。
可伸缩性
如果应用程序的“痛点”可以被定位到一两个不同的、作为关键组件的服务，那么扩展这
个应用程序就会容易很多。如果你将这一切进行了分解，并且让它们彼此独立，那么数据源也
可以独立。我们在考虑伸缩性的时候，就只需要面对更小的组件，因此是个很容易就可以解决
的问题。
互操作性
采用这种方式构建应用最大的优点之一，就是前端很少需要在意这些服务和元服务被托
管在哪里，这就将互操作性往前发展了一代。实际上，应用程序现在可以被多个不同的数据
源、多个不同的数据中心、多个不同的地区以及多个不同的供应商所调用。它成为了现代可伸
缩架构的一个可互操作性的混合物。
5.5.2　企业和政府的解决方案
对于企业和政府来说，颇为头疼的一个问题就是如何恰当地使用公共云系统，同时也可
以保密那些敏感数据。采用本章中讨论的一些方法，企业和政府部门就可以在两者之间获得
最佳的平衡。他们可以获得最大的敏捷性以及最快的上市时间。他们可以将关键的业务IT应
用实现为服务，从而可以通过托管在公共云上的Web应用和移动应用进行访问，而这些应用则
以一种安全和保密的方式发布到他们的员工和客户手中。这就意味着他们可以开始体验那些
早已被无数小型科技公司体会到的优点。
而且，采用元服务，就可以让多个独立的、负责应用不同方面的团队并行工作。因此，开
发大型应用的工作就变得相对容易很多，因为只需要让多个小型的团队专注于把一件事情做
得非常好就可以了。
5.6　摩尔定律的影响力
客户端JavaScript和胖客户端日趋流行并不仅仅是因为时髦。不能简单地认为这是一种比
较“酷”的开发应用程序的方法，事实上，这是由摩尔定律所驱动的，是由计算本身的特性所驱
动的。
在Web应用开发的早期阶段，用户的计算机运算速度通常非常缓慢。还记得网景公司的
Navigator浏览器吗？开发功能丰富的Web应用的惟一途径就是构建大型应用程序，让这些大
型程序运行在大型服务器上。因此，诸如亚马逊的早期应用只能更多地投资于硬件，而不是桌
面PC。由于只是装载Web页面就让PC难以应付，因此，这些任务只能在服务器端完成。
我们已经见证了摩尔定律的威力，用户的计算机运算速度越来越快。现在，一部智能电话
的运算速度已经超越了90年代最快的桌面PC机。这就是我们所讨论的新型应用开发的主要驱
动因素。现代计算机和智能手机比早期Web应用时代的计算机拥有快得多的计算能力，这就使
得应用开发逐渐转向客户端应用和胖客户端逻辑。
诸如SproutCore以及Cappuccino之类的框架，在网络浏览器（Internet Explorer）3的时代根本
无法应用。如今，硬件的能力得以飞速提升，因此客户端逻辑可以很快的运行，以近乎实时的
方式使用，从而可以创建一种更好的用户体验，例如Gmail和Twitter。同时，这也给广大的现代
应用开发者们在后台提供了一个更为容易，更具伸缩性的系统环境。
巨型Web应用程序的开发不再是最佳实践。它只是在Web开发的早期阶段最为实际的应用
开发方式。现在，我们已经进入到了客户端计算速度足够快的时代，从而可以开发出以前从来
不敢想象的强大应用。
在本章中我们所讨论的最佳实践是在CPU计算速度飞速提升的基础上逐渐演化出来的，
因此真实地反映了摩尔定律的影响力。这不是时髦的代言，事实上，这一定律正在改变着数代
开发者们的开发方式。
第6章　PaaS上的移动应用
移动应用的发展使得基于API创建服务的模式越来越流行，API是现在开发界最常用的。
这使得创建API并尽可能大范围支持它们成为必需的，而不再是锦上添花。
在开始看基于PaaS创建移动应用代码样例之前，我们先简单了解一些新技术的发展。
6.1　移动应用开发简史
在2007年iPhone投入市场之前，移动电话与环境紧密相关。想要创建第三方移动应用非常
困难，通常不太可能实现，而且对应用的功能有很严格的限制。早期电话的移动网页也有它们
特有的格式。它们包含自有版本的HTML，例如TTML（标记的文本标记语言）、WML（无限标记
语言）以及HDML（手持设备标记语言），为了能支持那些特定设备，它们被尽可能简化并新增
了一些少见的、随意的标记。
iPhone是第一部能用大众兼容的HTML网页浏览器加载的电话。
最初的iPhone通过HTML网站创建适用于手机屏幕的第三方应用。很明显，这些还不属于
移动应用：它们仍然是基于浏览器的。
移动应用开发中最早的变革是直接用HTML和CSS。这是移动应用创建方法中的转折点。
这时，创建移动应用仍然像网页应用开发。胖服务器端负责创建和展现所有信息，客户端只部
署很少的应用逻辑。
然而，随着iPhone逐渐成熟，具备本机移动应用的Android和Windows Phone设备投放市
场，情况彻底改变。开发者创建API嵌入到移动客户端本地由手机自己直接处理，不再生成
HTML和CSS。
客户端需要是Objective-C或者Java环境下的iOS或Android系统。很多展现逻辑和所有用
户体验组件都设计在客户端造成了胖客户端。因此我们的后台系统必须换个思路。这就需要
将API嵌入客户端系统由客户端调用。这种方法很大程度上映射出现代Web开发的演进：瘦客
户端逻辑。在网页上这意味着更多JavaScript，在移动开发领域，这意味着采用Objective-C或者
Java语言。
不管怎样，无论使用JavaScript调用API这样的瘦Web客户端还是采用Objective-C的本地移
动客户端，最终都要填充数据。无论哪种客户端调用，对这些数据的服务仍然是个问题。这种
情况推动了以面向资源方式创建轻量级JSON和XML服务及元服务的发展。
6.2　未来应用
展望未来，移动应用功能会越来越强，速度会越来越快。现如今的智能电话比10年前的大
型计算机功能强大很多，但相对现在的台式机它们还有很多功能和带宽的局限性。电话将会
越来越快、越来越便宜、越来越小，但功能却越来越强，内嵌更多客户端技术。
另一个需要考虑的重要成长因素是：我们几乎还没触及移动电话市场普及的表层。估计
2012年，大约有3亿~6亿部智能手机在用。但智能手机真正的市场估计接近30亿部。2012年的
智能手机普及只有2022年的10%~15%。
因此，我们不仅要预见应用的增强功能，还要看到使用这些应用的巨大潜在人群。
现在还有一个趋势值得注意：iOS和Android系统不同的流行度，Windows Phone手机和黑
莓手机狂热爱好者们也占有一部分市场。每种平台有其特有的创建应用的方式。随着智能手
机市场的成熟，这些技术间的差异会越来越小。开发者想要将更多创新融入功能中，一旦以一
种方式实现就能立刻在很多平台通用，充分利用整个移动市场。
最终，会有越来越多的人使用更多服务，对支持服务的后台应用造成更高的负荷。所以后
台服务和元服务会被广泛使用并且运行快速。当它们得到广泛使用时，人们对性能会有更高
的要求。
关键点：开发者需要思考采用什么方式来使这些应用的后台服务运行良好。这正是PaaS擅
长的。
6.3　数据结构
API驱动的开发模式使用了数据结构，将序列化信息打包发布到多个设备上。在本节中，
我们将学习两种工具：JSON和XML。
JSON和XML
大家熟悉的动作包括获取用户名和密码，外加一个朋友清单封装这个数据。用户想要将
这个数据从一台服务器发送给客户端的终端用户。有很多种方法来完成这个工作。
XML是Java中比较流行的常用方法。它也是很多企业级应用的重要工具。JSON技术相对
较新，它用JavaScript对象表示。JSON与JavaScript的关系是理解为什么采用这种格式的关键
点。
JSON最常用的使用方法之一是在Web前端使用JavaScript客户端。由于这个特点，JSON很
容易转变成Web客户端的JavaScript对象。既然很多移动应用最初都是基于网页的，因此这些
JavaScript的展现也基于网页。它们更便于阅读也没有那么繁琐。而且它们占带宽小，也是移动
设备上迅速增加了这些对象类型的另一个原因。
XML比较繁琐，这在处理复杂数据时比较有利。然而，它会使数据包体量增大很多，在移
动应用开发中，带宽有限、连接缓慢，因此传输的数据采用尽可能小的体量非常重要。这也是
很多移动应用选择JSON编码传输数据的原因。
作为参考，JSON有以下几种基本数据类型：
·字符串
·数值
·布尔类型
·空值
·哈希值
·数组
6.4　调用移动客户端的元服务
很多移动应用功能需要从互联网采集数据。如果我们创建第5章里提到的RESTful后台服
务并扩展部署在PaaS环境上，移动应用能在任何环境里快速、简单地使用这些服务。
6.4.1　iOS
用Objective-C开发的iOS本地应用能从主设备上快速获取数据。实现这个过程有很多种方
法，自己开发、利用开源代码或者专门的框架完成均可。
自己开发的第一步是运用iOS的异步网络操作：
1.创建NSMutableURLRequest对象表述URL字符串。
2.创建NSURLConnection对象装载URL并返回数据。
3.创建NSMutableData对象存放接收到的反馈信息。
下面是Objective-C代码应用范例：
-(void)load {
NSURL *myURL = [NSURL
URLWithString:@"http://example.com/users"];
NSMutableURLRequest *request = [NSMutableURLRequest
requestWithURL:myURL
cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
timeoutInterval:120];
[[NSURLConnection alloc] initWithRequest:request
delegate:self];
}-
(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
[mutableData appendData:data];
} -(void)connection:(NSURLConnection *)connection
didReceiveResponse:(NSURLResponse *)response {
mutableData = [[NSMutableData alloc] init];
} -(void)connection:(NSURLConnection *)connection
didFailWithError:(NSError *)error {
[mutableData release];
[connection release];
NSLog(@"Unable to fetch data");
}-
(void)connectionDidFinishLoading:
(NSURLConnection *)connection
{
NSLog(@"Succeeded! Received %d bytes of data",
[mutableData length]);
NSString *jsonResponse = [[[NSString alloc]
initWithData: mutableData
encoding: NSASCIIStringEncoding]
autorelease];
// 解析jsonResponse 并反馈到UI
}
在iOS 5中，苹果通过NSJSONSerialization类本地解析JSON。然而，像
JSONKit（https://github.com/johnezany/JSONKit）这类开源库解析JSON的速度会更快。
一旦获取数据并完成解析，将数据提供给前台用户使用的方法有很多：
·将控制器委派给现在有数据的视图。这是直接实现视图委派过程，但它不会在设备上保
留数据。
·将数据以列表或者归档格式存放在设备上。
·使用苹果Core Data framework将数据保存在设备上。
苹果的Core Data framework是iOS应用在电话上存放数据的标准方式。在iOS各种体验中，
它被广泛应用于UI控件。
iOS上的REST的框架：RestKit
RestKit（https://restkit.org）是iOS系统上很流行的开源框架，它能自动完成上述的很多工
作。它能处理网络抓包；JSON解析；自动将数据填充到Core Data；当我们提交Core Data对象到
应用商店（App Store）时，自动生成Core Data对象；支持对象映射系统以及其他更多工作。这里
给出一些示例代码，展示了向iOS应用中增加一个用户概念时，集成基于REST的URL
http://example.com/users是如何的简单：
// User.h
@interface User : NSObject
@property (strong, nonatomic) NSString *name;
@end
// User.m
@implementation User
@synthesize name;
@end
// MasterViewController.m
#import <RestKit/RestKit.h>
#import "User.h"
...
- (void)viewDidLoad
{
[super viewDidLoad];
RKURL *baseURL = [RKURL URLWithBaseURLString:@"http://example.com/users"];
RKObjectManager *objectManager = [RKObjectManager
objectManagerWithBaseURL:baseURL];
objectManager.client.baseURL = baseURL;
RKObjectMapping *userMapping =
[RKObjectMapping mappingForClass:[User class]];
[userMapping mapKeyPathsToAttributes:@"name", @"name", nil];
[objectManager.mappingProvider setMapping:venueMapping
forKeyPath:@"response.users"];
[self sendRequest];
}
很显然，我们可以看到：采用类似的库时是多么简单。但是，这样却失去了对很多内部细
节的控制。
6.4.2　Android
采用Java语言的Android本地应用也可以简单快速地访问元服务以获取数据。如同iOS一
样，也有多种不同的手段以实现这一过程，从自己动手构建到采用开源或者专有的框架。
自己动手写代码的第一步就是采用Android的异步网络操作：
1.将AsyncTask类扩展为异步任务类。
2.创建一个URLConnection并且将数据转换为字符串。
3.将结果处理为Java对象。
以下是实际过程中的一段Java代码示例：
// 通过新的GetRESTData().execute()在一个服务中执行;
// http://developer.android.com/reference/android/app/Service.html
private class GetRESTData extends AsyncTask <Void, Void, String> {
@Override
protected String doInBackground(Void... params) {
URL url = new URL("http://example.com/users");
URLConnection urlConnection = url.openConnection();
InputStream in = new
BufferedInputStream(urlConnection.getInputStream());
BufferedReader reader = new
BufferedReader(new InputStreamReader(in));
String result, line = reader.readLine();
result = line;
while((line = reader.readLine())!=null){
result += line;
}
in.close();
return result;
}
protected void onPostExecute(String restResult) {
// process the JSON string into a Java object
// and persist it into a SQLite database
}
}
注意，不要在活动内部实现任何Android的REST方法。因为活动只能用于用户界面以及与
用户体验相关的功能。代码应当永远从一个服务内部开始长时间的操作。Android服务可以用
于运行此类代码。
Android可以通过org.json.JSONObject类实现对JSON的本地化解析。也有其他一些开源库
可以在Android上解析JSON，例如JSONLib（http://json-lib.sourceforge.net）、
FlexJSON（http://flexjson.sourceforge.net）以及Gson（http://code.google.com/plgoogle-gson）。
在获取了数据并解析之后，就需要立刻将数据持久化。在Android上最好采用SQLite。针对
来自REST服务的新数据，开发者应当采用同步适配器来执行常规检查。同步适配器可以将数
据获取的过程从拉动架构转换为推动架构，从而极大地延长电池寿命。
Android上的REST框架：Restlet
如同iOS上的RestKit一样，在Android上也有类似支持REST的库。实际上，由于Android采
用Java，因此，可以在Java本地移动应用中采用与Web应用中同样的REST客户端库。
Restlet（http://www.restlet.org/）就是这样的一个流行的库，可以在从基于REST的源获取数据
时，极大地节省开发者的时间和精力。
有很多很好的关于Restlet的教程和书。可以参考一下由Jerome Louvel、Thierry Templier、
Thierry Boileau创建的网站（http://bit.ly/137mPe6）和《Restlet从入门到精通》
（http://www.manning.com/louvel/）这本书。
以下就是一个RestLet实现的简单例子：
public interface UserResource {
@Get
public User retrieve();
@Put
public void store(User user);
@Delete
public void remove();
} ClientResource cr =
new ClientResource("http://example.com/users/123");
// 获取用户对象
UserResource resource = cr.wrap(UserResource.class);
User user = resource.retrieve();
Restlet管理着JSON的解析以及很多其他方面的事情，但是用户类依然得负责将数据持久
化到一个SQLite数据库中。如果要详细地了解这方面的信息，请参考由Ian F.。Darwin所著的
《Android大全》（Android Cookbook，特别是第11章，其中详细介绍了如何解析JSON和持久化数
据）。
6.5　PaaS如何让移动后端开发更容易
在本章中，我们讨论了如何简单地通过后端的基于REST的元服务，将动态数据融入移动
应用。当以这种方式开发移动应用时，PaaS还可以带来其他好处。在本节中将就其中的一些进
行介绍。
6.5.1　构建移动后端元服务更快
如同第5章中所介绍的，构建元服务，从而给移动和Web前端提供支持，采用平台即服务
的方法是很容易做到的。事实上，当采用这种方式时，在PaaS上从零开始构建是一种最佳实
践。这些服务将拥有比较少的代码、易维护、易扩展。
当采用PaaS构建元服务、部署一个大型的N层服务器集群并对其进行管理的时候，可能只
需要数秒钟的时间，不需要几周，更不需要几个月。
采用PaaS，可以让我们以前所未有的速度，方便地构建和运行元服务。
6.5.2　采用PaaS扩展元服务更容易
在PaaS上扩展元服务很简单。如果应用程序是模块化的，并且不需要持续访问磁盘，那么
可以快速容易地增加更多的实例，从而极大地提升并发级别。当数以千计（或者上百万）的用
户开始采用开发者提供的移动应用时，增加处理能力不再是件令人头疼的事情，只是简单的
一个API调用就可以做到这点。
事实上，很多PaaS供应商提供基于REST的API，可以用于将扩展的过程自动化处理。
6.5.3　选择底层核心服务更容易
开发者可能只有1000个用户，但是这些用户可能上传100000000张图片。PaaS供应商可以
将对后端服务的管理和扩展变得更容易，从而高效、快速地处理这些类型的服务。
6.5.4　可移植的服务可以被复用在多个设备上
在构建了元服务，并且部署在PaaS平台上之后，就可以通过iOS、Android或者Windows
Phone的智能手机和平板电脑来访问。这些服务还可以用于Web展现。这是一种非常强大的方
法，可以在构建应用的时候最大化资源的利用效率。
6.6　服务于更多用户
如今，我们见证了各种不同类型的应用的快速增长。有些情况下，开发者可能在地下室里
开发出这些应用，然后再运用PaaS，或者本书前面内容中所讨论过的某种方法，例如专有主
机。如果足够幸运，他们的应用也许会作为特色应用出现在某个应用商店。然后，如同我们所
看到的那样，保证计算资源的压力有些时候可以毁掉开发者的生意。
对于那些没有采用PaaS来扩展应用的开发者来说，随着移动设备的快速增长，这类问题
正变得日益严重。移动应用的用户数量正在急剧膨胀，这一点也令创建一个可以扩展的基础
设施变得更加困难，即使是对于最简单的手机应用程序也一样。
第7章　核心服务简介
当选择PaaS供应商的时候，非常重要的一点就是搞清楚自己到底想要什么。本章将着重
讨论一下核心服务，而不只是运行一个应用程序。所谓的核心服务是指提供数据存储、SQL、
NoSQL、查询以及其他给应用提供支持的功能。核心服务还包括电子邮件监控、缓存和数据管
理、资源消耗和分析等，其中每一个都可能是一个完整的应用程序。
通常情况下，PaaS供应商会自己管理这些核心服务，或者通过一个与PaaS平台紧密集成
的第三方插件系统管理核心服务。不管哪种方式，采用PaaS的时候，我们不需要自己去管理这
么多的核心服务。毫无疑问，这将给我们带来很大的好处（开发者真的想花费时间去调整
my.cnf文件吗），但是也有一些重要的权衡点，在本章中我们将进一步讨论。
本章的目标就是帮助大家认识到可以从基于PaaS的核心服务中得到些什么，以及在承诺
将产品代码运行在PaaS系统之前，可以向候选PaaS供应商问些什么问题。
7.1　非PaaS核心服务
从本质上来说PaaS是一个高度托管的环境。我们不需要担心扩展性。也不需要担心应用
程序背后的运维，而只需要知道对应用进行扩展或者增加规模，最主要的决定则是：是否需要
增加RAM或者更多的运行实例。而这些也将会是在谈及核心服务如MySQL和MongoDB的时
候，我们所期望所获得的。实际上，大多数时候，核心服务可能会和应用程序一样难以运行、
扩展和管理，甚至有过之而无不及。这是因为，如果自己管理核心服务，每增加一个核心服务
都会增加巨大的运维复杂性。
在考虑托管和管理一个MySQL服务时，同时也思考一下，打算花多少时间来对其进行管
理和监控，以及处理故障。在处理过巨大的数据存储以及TB的数据之后，我们就会很清楚以
分布式的方式管理MySQL、PostgreSQL、MongoDB以及内存数据库只不过是一个技术上的挑
战而已，如同管理应用程序代码一样。
在非PaaS环境中，开发者得自己安装配置MySQL，然后还得负责对其进行调整和优化。可
能还得设置RAID磁盘阵列以用于备份和冗余。随后，可能还得设计外部备份计划。也许还得
配备主－从复制，或者具备从设备的主－主复制机制。然后，可能还得加上心跳监测，以确保
系统能持续工作，并在出现故障的时候及时进行处理。开发者必须无时无刻地对这些核心服
务进行调整、监控、维护。除此之外，还得留意各种类型的底层网络设置，以确保对它们进行
持续维护和管理，并及时处理安全补丁和升级。
7.2　评估PaaS服务
在PaaS环境中，这些维护工作中的绝大部分都自动完成了。当然，PaaS供应商的不同必然
会导致运维质量的显著不同。因此，有时候，评估PaaS供应商的核心服务与评估其他特性一样
重要。
本章的最后附上了一个问题列表，在与某个供应商签约之前，这些问题都应当有比较好
的答案。在整个决策过程的早期阶段考虑这些问题将是非常重要的。
考虑一下我们最终会遇到哪些限制：
·允许的最大数据存储是多少？
·最大的磁盘I/O是多少？
·当达到上限时会发生什么？
·每个服务可用的RAM是多少？
·如果需要扩展，如何让服务获取更多的资源？
在考虑PaaS供应商时，事先了解到这些信息非常重要，因为通过这些信息可以了解到能
否对应用程序进行扩展。
记住一点，由于存在多个应用程序，很容易就可以让数据达到容量的上限。大多数应用不
需要TB的磁盘存储，有的甚至不需要GB大小的。通常情况下，大多数应用程序只需要数十MB
的存储空间，但是得准备数百MB的空间以备扩展。
因此，我们需要准备好并且能够预测将要在MongoDB、PostgreSQL、Redis或者内存数据库
中存储多少数据。与此同时，得搞清楚这个问题的答案，即“我的PaaS平台是否允许我进行扩
展？抑或平台有诸多的限制，而导致我一旦选择了之后就被约束？”所以，我们需要事先做些
功课，交流并思考一下应用程序在更高的条件下需要哪些资源？
有些PaaS供应商可能在某些方面比其他供应商要好些。但是，总体说来，大多数PaaS平台
都已经对数据库、配置文件以及网络接口进行了足够优化，这样就显得要远远好于上手即用
的水平。同时，平台也仔细思考和处理过时效恢复以及冗余等方面的问题，而这些问题一般比
较难以解决，尤其对于开发者来说。即使是专业的运维团队也常常需要花费数周，或者数月的
时间来计划和构造这些运维过程，以便让那些PaaS管理的服务拆箱即用。
在核心服务上采用PaaS所获得的好处将是巨大的。例如，可以很快地开始；很快地创建原
型；更快地编写更多的代码；不需要担心如何分发内存管理或者主－主方式的MySQL数据库；
不需要花精力搞清楚如何穿越邮件服务的SMTP的过滤器，以及Google和Hotmail的垃圾邮件
过滤器发送邮件。PaaS可以分担绝大部分的负载。因为，PaaS供应商可以帮助我们做完所有这
一切，从而给予我们更大的灵活性和更快的速度。
7.3　采用托管的数据库和PaaS以节省时间
当尝试自己设置托管服务的时候，最让人头疼的事情之一就是数据库。管理数据库并进
行备份所花费的时间可能比写应用程序的代码要多出很多。如果事先能够做好功课，并且做
出明智的选择，那么在PaaS平台上采用托管的SQL核心服务将带来极大的好处。
7.3.1　SQL
采用SQL和PaaS可以节省大量的时间。借助于创建可扩展SQL方案的专家经验的投入，我
们可以更快地完成工作，但是，值得强调的是，也有一些需要注意的地方。
开发者需要考虑最大允许创建多少查询。而且，针对核心SQL服务也有不同的收费方式：
·每个月有多少数据库查询
·数据存储能力
·并发访问数据的用户数量
·以上这些的组合
这些服务收费方式可能非常不同，因此，依据不同的特定的使用情况，所产生的成本可能
差异也很大。
除了将要被创建的应用程序，还有其他一些因素可以影响我们的决定。在考虑是选择一
个托管的PaaS的核心服务还是自己干的时候，很多事情可以影响到最终的结果。
在未来的12个月内，针对你的特定情况，以下哪些问题的答案可能是真的呢？
1.在大多数情况下，从理论上说，需要缓存多少数据？
a.超过15%
b.在10%~50%之间
c.低于10%
2.你的应用中有多少是由动态数据驱动的？有多少是静态的内容或者对象存储？
a.低于40%的动态内容
b.40%~60%之间的动态内容
c.超过60%的动态内容
3.数据库中存储了多少数据？
a.低于5GB
b.在5GB~50GB之间
c.超过50GB
4.在一个表中存储多少记录？
a.低于10000000
b.在10000000~100000000之间
c.超过100000000
5.需要多少个表？
a.少于20个
b.在20~100之间
c.多于100个
6.访问数据的频度有多高？
a.每秒低于10次
b.每秒10~100次
c.每秒超过100次
7.有多少数据需要被频繁和重复访问？
a.少于1GB
b.在1GB~10GB之间
c.超过10GB
如果所有这些问题中有5~7个的答案是（a），其他的是（b），那么这个开发者可能比较适合
采用PaaS托管的核心SQL服务。
如果这些问题中有3~7个的答案是（b），那么开发者就需要对PaaS的选项进行仔细评估，
并且在与某个选定的PaaS供应商签约之前进行负载测试。
如果这些问题中有2~3个的答案是（c），那么在有能力的情况下，开发者可能得自己运行
核心SQL服务，或者选择一个供应商，能够针对所需要的SQL服务级别提供特定的扩展服务。
虽然，依旧可以在应用中采用PaaS，但如果很有可能超出这些指导原则，采用托管的核心数据
服务可能不是一个好方法。
有些应用也许可以很好地适应这一模式，其他一些则不然。以一个博客系统（WordPress）
的数据库为例。这是一个可以被高度缓存的应用，因此，不需要在每个查询中都访问数据库。
可以在PaaS应用环境中被很好地缓存。在此基础上，可以进一步优化，并且以相对较低的成本
运行，而不需要存储很多的数据。
但是，如果PaaS平台对数据库的并发进行了限制，那么在开发者的博客或者网站需要处
理高负载的时候就会碰到问题。一般情况下，博客系统不需要每秒处理10次访问请求，即使这
个访问频率也算不少了。但是，可能有些场合下，开发者需要确保网站能够每秒钟处理1000次
请求。如果在设计数据库的时候，只能每秒处理10次并发请求，那么应用就没有那个能力同时
为1000人提供服务。从而，大多数人都将会看到错误页面。这里的结论就是：事先知道这些限
制和约束非常重要。
另外，如果按照请求数量付费，并且对于并发没有任何限制，那么开发者就需要对代码进
行优化，确保请求数量的最小化，否则将要付出高昂的费用。
因此，虽然必须密切关注数据库服务是如何被收取费用的，但是潜在的好处，即节省时间
和快速行动，也是非常重要的。
7.3.2　NoSQL
NoSQL是以键/值或者文档方式存储的数据库，它日益流行并且有诸多的形式，例如
MongoDB、CouchDB、Redis、Cassandra以及Riak。这些技术可以比传统的SQL存储机制提供更
好的扩展方式。
采用PaaS和NoSQL所带来的收益与采用PaaS和SQL类似，例如可以很快开始，不需要担心
一些运维任务，诸如运行MongoDB服务、对其进行管理或者调整优化。
对于自管理的NoSQL来说，优点之一就是可以比管理MySQL、PostgreSQL或者传统数据库
更容易扩展，即只需要增加新的虚拟机并将这些虚拟机加入配置中。并不是所有的PaaS供应
商都允许非常容易的扩展。因此，作为开发者，在应用的扩展要求超出NoSQL的最大能力的情
况下，制订应急计划是个不错的做法。
在未来12个月之内，以下哪些问题的答案可能是真的呢？
1.数据库需要存储多少数据？
a.少于5GB
b.在5GB~50GB之间
c.超过50GB
2.在表中需要存储多少记录或者文档？
a.少于100000000
b.在100000000~1000000000之间
c.超过1000000000
3.访问数据的频率有多高？
a.每秒少于10次
b.每秒在10次~100次之间
c.每秒超过100次
4.有多少数据需要被频繁和重复访问？
a.少于1GB
b.在1GB~10GB之间
c.超过10GB
如果所有这些问题中有3~4个的答案是（a），其他的是（b），那么这个开发者可能比较适合
采用PaaS托管的核心SQL服务。
如果这些问题中有2~4个的答案是（b），那么开发者就需要对PaaS的选项进行仔细评估，
并且在与某个选定的PaaS供应商签约之前进行负载测试。
如果这些问题中有2~4个的答案是（c），那么在有能力的情况下，开发者可能得自己运行
核心SQL服务，或者选择一个供应商，能够针对所需要的NoSQL服务级别提供特定的扩展服
务。虽然，依旧可以在应用中采用PaaS，但如果很有可能超出这些指导原则的话，采用托管的
核心数据服务可能不是一个好的方法。
7.4　缓存和PaaS：冗余
一般情况下，缓存没有状态并且容易丢失。流行的缓存技术有很多，有些是开源的，如内
存缓存和Encache（纯Java的进程内缓存框架）；有些是专有的，例如针对Java的TerraCotta。这些
框架不需要像SQL或者NoSQL数据库那么大的开销，因此，很容易对它们进行扩展。由于冗余
机制能发挥作用，所以，即使宕机了也不会导致重大问题。
在PaaS上采用缓存所获得的好处，实际上可以抵消掉在PaaS上采用数据库时所造成的麻
烦，这是因为实现缓存最难的部分在于设置冗余机制，而在PaaS环境中这一切已经被很好地
处理了。因此，再次强调，一定要与PaaS供应商确认他们可以提供冗余和失效恢复机制，这是
在前期研究的时候非常重要的一点。
另外需要考虑到的一个约束就是能缓存多少数据。有时候，PaaS供应商会限制只能缓存
一定量的数据。通常，这已经足够，因为大多数缓存系统会自动替换旧的数据（使用最少的数
据），因此，存储在内存中的通常是最重要的数据。但是，如果数据库增长超出了限制，不停的
需要访问后端SQL或者NoSQL数据，而PaaS供应商不能提升限制的上限时，就得考虑一下自己
去托管缓存的方式。
由于缓存本质上是易失性的，因此，从一个托管在PaaS上的缓存迁移到一个自己管理的
缓存系统将是一个非常艰难的过程。因此，除非缓存已经达到了上限，否则，自己去设置一个
缓存系统并不是那么的重要。
7.5　解决Email的挑战
在云环境下发送邮件可能是一件非常困难的事情。当采用亚马逊的Web服务、Rackspace
或者Azure的虚拟机时，他们通常都有一些IP地址，而这些IP地址会被Email供应商所屏蔽。诸
如AOL和Gmail之类的大型Email供应商都会屏蔽掉一大批为公共云供应商所拥有的IP地址，
因为这些IP地址过去为垃圾邮件制作者所利用。
在使用公共云的时候，很有可能应用程序运行在一个被Email供应商加入黑名单的IP地址
上，从而导致一个问题，即在PaaS的公共云环境下，如何将电子邮件发送给用户？另外，对于
有些程序来说，可能会有这么一个重要的问题：如何接受和处理应用程序内部的邮件？
对于博客系统来说，这也许不是个问题。但是，对于交互式服务，并且服务的某些部分需
要处理电子邮件的话，那么，在使用公共云的时候，开发者将面临一组独特的挑战。
最聪明的做法就是使用一个托管的电子邮件服务。通常这类服务不同于数据库或者缓存
服务。这类服务可能并不是由PaaS供应商本地托管。一般情况下，这是一个独立运行的软件服
务，而且，通常是按照要发送的邮件数量收取费用。有些场合下，PaaS供应商会给开发者设立
一个账号，从而建立起应用到邮件服务之间的连接。这类服务可以帮助开发者发送邮件，要么
以一次发送一个的方式或者以一次发送一批的方式进行发送。采用这种方式，关键的优势在
于从这些账号发送的电子邮件早已被列入Gmail、AOL和Hotmail的白名单列表，就是说这些邮
件可以被发送到用户手中，而如果开发者直接发送的话则会被垃圾邮件过滤器屏蔽。
有一点可能被忽略了，那就是被列入白名单以及继续保持在白名单上，实际上这件工作
本身就是个全职的工作。因为，要跟上Google、AOL、微软以及Yahoo强加的一些最新要求是一
件非常困难的事情。要保证大多数用户能够持续的接收信息，从而每天只需要发送数十封邮
件，这是比较容易做到的。然而，如果每天需要发送成百上千封邮件，将会变得不可思议的困
难。总的说来，采用这些服务还是比较合算的。当然，开发者可以通过第三方做到这一点，但
是，这些第三方有可能也是PaaS供应商或者IaaS供应商所管理的。
这里给出一个流行的邮件服务的列表：
·Sendgrid（http://sendgrid.com）
·Rakspace的Mailgun（发送和接受Email）（http://www.mailgun.com）
·亚马逊的简单电子邮件服务（http://aws.amazon.com/ses）
·MailChimp（http://mailchimp.com）
·Campaign监视器（http://www.campaign monitor.com）
7.6　监控的重要性
不管是运行自己的基础设施，还是在PaaS的基础上构建，需要面对同样的问题，即监控应
用程序的每一个部分。
这就意味着，作为开发者，必须了解程序的负载（当前负载和历史负载）、数据库的运行情
况（事务、磁盘I/O、存储器等）。还意味着，必须清楚有多少人并发地获取数据（或者试图这么
做），以及服务是否能够成功地满足这些要求。
7.6.1　考虑一下可选项
PaaS上的监控选项有很多，备选项之间可能有很大的差异。有些PaaS供应商可以提供深
入的分析手段，并且内置监控功能；其他一些则可能需要第三方集成；还有一些则提供很少甚
至没有任何的分析手段。
如同电子邮件服务一样，监控也可以通过第三方或者PaaS平台提供。很多情况下，两种方
法兼而有之。PaaS平台可以为开发者提供一组关于应用程序的信息；监控可以给出一些统计数
据，以及一些基线信息，也许通过与第三方监控服务的集成还可以提供更为深入的信息。例
如，作为第三方SaaS服务的New Relic和AppFirst，可以给出非常详细的信息，诸如应用程序是
否运行良好，如果有错误发生，或者程序停止工作，或者达到资源的上限，则可以及时通知开
发者。这类服务还可以给出应用需要花费多长时间来对用户进行响应，并给出平均和历史信
息。
监控之所以如此重要还有另外一个原因。通常情况下，Paas非常容易做到水平扩展，有时
候也可以做到垂直扩展。最困难的地方在于知道什么时候需要扩展。绝大部分PaaS服务没有
自动扩展功能，从而没有办法决定需要在什么时候给应用程序增加更多的处理能力。但是，如
果有一个主动的监控服务，可以在应用程序达到某些资源上限，或者运行缓慢的时候通知我
们，以便我们采取相应的行动。
借助于监控服务提供的信息，开发者就可以设置一些阈值，甚至可以在PaaS环境下构建
自己的自动扩展功能。或者，可以直接进入控制台，一边将滚动条往上移动，一边说道“我现在
就需要更多的资源”。
不管怎么说，在PaaS上运行程序的时候，详细的监控信息至关重要，而且永远不应该被忽
略。PaaS平台的一大魅力就在于：开发者可以不需要担心应用程序背后的运维工作，或者调整
和配置设置。但是，归根结底，开发者还是需要知道应用程序运行的性能如何。监控就是做到
这一点最基本的方法。监控永远不能被忽略，它应当被包含在运行于PaaS环境下的每一个应
用程序中。
以下是一个流行的监控服务列表：
·New Relic（http://newrelic.com）
·AppFirst（http://www.appfirst.com）
·AppDynamics（http://www.appdrynamics.com）
7.6.2　放眼未来
服务是应用程序生命周期中的调味品。它们可以让应用程序变得更为有趣。虽然它们可
以给程序增加价值和深度，但是每当增加一个新服务的时候，就给应用程序的运行和管理增
加了一个复杂的层次以及一组限制，这一点必须认识到。
当然，采用服务也可以带来很多的好处。每当开发者评估是自己构建或者运行的时候，总
应该考虑一下托管服务是否是一个更好的选择，因为托管服务很可能节省大量的时间和金
钱。但是，在选择托管服务的时候，一定要认识到服务多种不同的收费方式，即使是不同的供
应商提供的相同的服务。
必须要了解应用程序是如何工作的，然后利用这一信息提前数月或者数年来对服务进行
评估，以决定服务是否依然满足要求。这是一个必做的功课。
采用托管服务的责任总是伴随着费用。这一费用需要提前计划。
7.7　负载测试
与托管服务打交道的时候，其中非常重要的一点就是了解扩展的限制。为了找出这些限
制，就需要进行性能追踪和负载测试。
在大多数PaaS环境下，有一些插件甚至本地服务可以做这些事情。这些服务可以对我们
在本章中讨论的所有方面进行测试—监控、数据库容量、并发、限制、延迟，这样就可以知道
在1000个人访问网站时，程序的性能如何。
针对每个加入应用代码中的其他类型的服务，都必须应用这些监控服务。可以将它们分
别使用在不同的级别上。这样就可以看到当10000000或者100000以上的用户并发访问站点
时，程序的运行状况如何，从而可以测试一下应用的能力计划。也可以提前做些预演，如增加
应用的实例个数，以及增加数据库的容量，以确保当应用程序在压力下运行时，团队可以积极
地采取一些行动。
总结：性能和负载测试服务对于解决我们所讨论过的扩展场景中所遇到的问题来说至关
重要。
以下是一些流行的负载测试服务：
·Blitz（http://blitz.io）
·Mu Dynamics（http://www.mudynamics.com）
7.8　计划升级途径
最后一个并且非常重要的考虑，在本章前面曾经提到过，即开发者必须提前计划。
开发者应当考虑当应用达到资源上限的时候，如何进行升级。有两种清晰的方法可供选
择：
·在PaaS内部提升资源的上限
·运行和管理自己的服务
具体选择哪种方法则取决于选择的是什么样的PaaS；它是如何管理系统的；以及开发者能
够在多大程度上访问这些系统。有些PaaS供应商可以让我们无缝的实现升级，在不作任何修
改的情况下增加资源、消耗以及并发能力。
但是，应当认识到，也有些供应商会要求开发者选择一个新的数据容量的计划，他们会由
此创建一个独立的数据存储容器，这个数据存储具备更高的上限，因此容量更大、功能更强
大。但是，开发者必须要将数据迁移到这个新的数据存储，并为此修改代码。有些情况下，
PaaS供应商可以帮着做完这些迁移。但是这需要时间。因此，在切换的过程中，就需要更多的
停机时间，以便迁移到这个大容量存储。
从托管服务迁移到非托管服务，从而自己去管理服务的过程是与此类似的。如果需要创
建一个自己的数据库，以便拥有比PaaS更强的处理能力，就需要将这个数据库设置为单独的
容器，并且搞清楚与我们在这里讨论过的类似的问题，即往新的数据库迁移的过程中如何关
闭网站。
存储选项
在提前计划PaaS升级的时候，就应当考虑数据存储在哪里，以及如何自己去运行数据库
这些问题。例如，如果平台即服务被托管在亚马逊位于美国东部的数据中心的Web服务商，那
么在数据中心，就得采用虚拟机，并且自己管理MySQL。开发者可能得在AWS内部增加虚拟机
的数量，以便减少应用访问数据存储的延迟。由于这些虚拟机位于同一个网络基础设施之内，
因此作为回报，开发者获得了很高的访问权限、很高的访问速度以及很高的性能。虽然这一过
程比较困难，但是肯定是可以做到的。
其他的托管供应商也可以做到类似的事情。我们在Rackspace、HP云以及Azure都可以看到
类似的解决方案：如果应用运行在其中任何一种基础设施上，开发者就可以通过增加位于同一
基础设施内的虚拟机的数量，以获得应用访问数据的低延时。开发者不需要管理应用以及对
应用的扩展，但是必须要管理数据库。
或者，某些IaaS供应商也可以管理我们的服务。有时候，他们甚至可以提供比PaaS供应商
更高的控制级别。其中的一个例子就是亚马逊的关系数据库服务（RDS）。它具有丰富的功能，
因此可以被作为其自管理的服务，独立于任何PaaS运行。因此，如果开发者选择了某个PaaS来
运行程序，那么就可以在同一基础设施供应商上选择采用亚马逊的RDS，以便获得较低的延
迟。应用程序可以直接与基于RDS的数据库交互。或者，开发者需要将应用迁移到另外一个位
于AWS上的PaaS供应商时，依然可以采用原先的RDS，但已经是通过完全不同的PaaS供应商
来访问了。这样，应用程序就拥有了运行位置的灵活性。
总之，在管理数据的时候，如何解决扩展的约束这个问题必须要提前思考并计划。在考虑
到了所有这些可能的场景之后，就可以相对比较容易的在PaaS上采用托管服务了。
在为托管服务选择PaaS的时候，对供应商的特征及限制进行事先评估是非常必要的。以
下就是在选择一个PaaS供应商的时候可以问的问题：
一般问题
·应用可以访问多少数据存储？
·应用需要持久磁盘存储吗？
·应用可以将文件写到磁盘上吗？
·写到磁盘的文件是暂时的吗？
·一个应用实例可以使用多少RAM？
·如果应用达到RAM上限，会发生什么情况？
数据库
·供应商如何收费？
·按每月的查询数量？
·按数据存储容量？
·按并发连接数？
·提供冗余存储吗？
·提供失效恢复机制吗？
缓存
·是否提供冗余？
·是否有失效恢复机制？
电子邮件
·供应商是否可以帮助建立应用和邮件服务之间的连接？
·供应商是否可以给你建立一个邮件账户？
·它采用的第三方邮件服务是什么？
监控
·供应商可以提供什么类型的监控信息？
·你可以拥有什么控制？
·供应商是否具有自动扩展功能？
·在达到资源上限时，供应商是否会通知你？
性能
·供应商是否提供性能统计或者具备这些功能的插件？
·供应商是否提供负载测试服务？
第8章　为什么不选择PaaS
本书的大部分内容都专注于PaaS的好处，以及为什么要采用某个PaaS供应商的强有力的
理由。但是，本章中将讨论一下硬币的另外一面：在哪些情况下PaaS可能不会带来益处？
答案取决于你是谁，以及来自哪里。对于来自企业的开发者，中小型公司的开发者，或者
独立开发者甚至黑客而言，约束是非常不同的。在这其中每个案例中，都可以透过不同的视角
来看待平台即服务。通过这些视角，开发者还需要考虑两种非常不同的使用PaaS的方式所带
来的利与弊：公共云PaaS和私有云PaaS。
8.1　公共云与私有云
公共云通常运行在某个公共的基础设施即服务平台上（例如亚马逊的Web服务），在这些
平台上我们可以看到PaaS供应商，诸如Heroku、EngineYard以及AppFog的身影。在很多PaaS
上，开发者没有办法选择代码的运行位置。对于服务是如何运行的没有太多的控制，而且也没
有办法看到操作系统的底层机制。开发者负责提供代码，PaaS则负责其他所有的事情。这个方
式的缺点在于，开发者对于服务到底是怎么运行的没有太多的了解。
什么是私有云
通常说来，术语“私有云”是指运行在开发者自己控制的硬件上的计算平台。然而，私有云
是一个有争议性的术语。有些人甚至认为私有云根本不存在，因为如果自己运行那么就不是
云。其他一些人则认为如果在自己运行或者管理的服务器上运行IaaS或者PaaS技术，那么就足
够称之为云了。
为了方便讨论，我们假设私有云就是指在一个自己拥有或者管理服务器的环境中运行
IaaS或者PaaS技术。
对于大多数开发者来说，私有云并不像公共云那么熟悉。当大家提到PaaS时，通常脑海中
出现的是公共PaaS。这是大多数人习以为常的PaaS。
私有云有着多种不同的形式，但是从根本上说必须包含在自己的硬件上运行PaaS，可能
运行在自己的服务器上。它可以运行在企业预置的IaaS平台上，例如OpenStack、vSphere、
CloudStack、或者Eucalyptus，甚至直接运行在自己的非虚拟化硬件上。不同之处在于，采用私
有云的PaaS，开发者得负责运行PaaS代码，同时也得负责对代码本身的管理。
人们运行私有云，以便获得与公共云类似的功能和部署机制来运行应用。但是同时必须
负责对PaaS代码进行运行和维护，并确保它能够持续运行。这赋予了开发者更多的灵活性，因
为可以获得对服务器更多的控制。开发者可以使用自己的服务器，不需要绑定在特定的基础
设施供应商之上。
还有一些供应商，例如AppFog和OpenShift，实际上可以同时运行公共和私有云。这些供应
商可以让人们选择将应用托管在现有的专有基础设施之上，还是在一个公共云上。但是，绝大
多数其他的PaaS供应商不会提供这项选择。
8.2　中小型公司：如何选择
对于小型或者中型企业中的开发者来说，对于代码运行在什么地方的限制条件，处理起
来相对灵活。就在何处运行应用这个问题，开发者通常有一定的话语权。一般情况下，对于公
共云隐私方面的担忧并不是一个非常强烈的理由，因此不像大型企业的开发者那样这是个令
人烦恼的问题。这一点给了开发者们一定的权衡，他们可以选择认为正确的运行环境。但是，
考虑一下灵活性方面的可选方案，仍然是一个不错的观点。关于公共和私有云，要确保跟你的
经理讨论，并搞清楚他们是否将来在某一方面有着强烈的倾向。
而对于独立开发者来说，则拥有任意选择的自由。出人意料，也许开发者仍然会选择采用
私有云，特别当他是一个多面手的时候。在自己的硬件上安装Cloud Foundry（PaaS）或者
OpenStack（IaaS）当然非常困难，但搞清楚它们是如何工作的，又是一件充满乐趣的事情。
很多独立开发者通常只是想让所有的一切能正常运行，而不需要太多的担心维护问题，
因此，对于大多数独立开发者来说，公共云PaaS是正确的选择。开发者不需要担心服务器或者
网络故障，也不需要担心保持操作系统的更新。另外一方面，对于一个独立的多面手，他可能
对于这一切是如何工作的充满好奇，或者只是想要更多的控制，或者希望能够做出一些或小
或大的修改。那么，一个私有云就可以提供所有这些灵活性。查看代码、做出修改、然后再运
行这些修改，这一切会让人感到得到了充分的授权。
从这个角度，我们来看看私有云PaaS的一些可供选择项。
开源还是闭源
在私有云PaaS的竞技场上，开发者可以选择开源或者闭源方案。企业开发者和独立黑客
则可以对两者都进行评估。
例如，Cloud Foundry是一个开源的项目，它可以运行很多种不同的技术，而你根本不用关
心它运行在哪里，以及如何运行。事实上，它甚至可以运行在笔记本电脑上，依然可以提供
PaaS的功能。不利的一面在于以产品模式运行相当的困难。这是一个大型分布式程序，对其进
行扩展是一个非常困难的问题。有些供应商，如AppFog和Tier3可以做到这一点，当然，开发者
也可以选择自己做。
另外一个开源的工具就是红帽子（RedHat）的OpenShift。开发者也可以自己捣鼓并运行这
个工具。但是这个工具的架构与Cloud Foundry是不同的。可以从红帽子获取托管的版本。对于
独立的黑客来说，这两个方案都是业界领先的开源项目。
Cloudify是另外一个开源PaaS。相对于独立开发者，这个项目更专注于企业用户。
GigaSpaces（Cloudify的创立者）对其提供商业支持。虽然它更多地面向java，但是它的确提供了
对其他一些技术的支持。（比较Cloudify与Cloud Foundry的方案，后者对很多技术提供了强有力
的支持，例如：Java、Node、PHP、Ruby、Python，以及很多其他技术。）
Apprenda是一个专门为.NET所构建的闭源PaaS。相比于其他面向.NET的PaaS供应商，它
通过一些运行时.NET功能，从而可以提供很多额外的好处。
以下是一些可以作为起点的资源：
·Cloud Foundry（http://cloudfoundry.org/）
·OpenShift（https://openshift.redhat.com/）
·Cloudify（http://www.cloudifysource.org/）
·Apprenda（http://apprenda.com/）
8.3　大型企业级用户：如何选择
很多企业和大型商业组织对于数据有着严格的限制。他们不允许数据离开数据中心，因
此，在企业评估平台即服务的时候，公共云PaaS通常会出局，因为他们没有办法连接到他们需
要的数据源。这一先决条件让私有云PaaS成为一个对大多数企业来说比较可行的方案。因此，
大型企业内部的开发者必须说服他们的技术领导在企业内部应用PaaS。
但是，对于大型商业组织内部的某些应用案例来说，公共云作为一个可以实现的方案从
而被接受的数量也在持续增加，即运行那些非运营核心并且非数据敏感的应用系统。在企业
内部，大多数公共云被采用的三个领域分别是移动应用、社交以及消费者Web应用。这些类别
的应用通常不需要那么多的敏感数据就可以工作。因此，在这些场合下，公共云方案是比较容
易被接受的。
作为一个开发者，在考虑各种方案的时候尤其要小心，这一点至关重要。在确定某个PaaS
供应商之前，非常重要的一点就是了解一下它是否提供一个预置的私有云。如果开始的时候
选择了公共云PaaS，并且没有办法转到预置的私有云，那么最终可能得选择一个完全不同的
PaaS。而这将会让开发工作异常艰难，并且会需要很多的事务性工作，因为企业可能会选择一
个私有云PaaS。在某些时候，他们可能会强迫你转向这个私有云。如果你选择的PaaS同时提供
公共云和私有云，那么在需要转向私有云的时候就具备了更大的灵活性。原来开发的接口在
私有云上将同样可以发挥作用。
8.4　PaaS的限制
平台即服务有很多好处。但是由于本章是要讨论PaaS的限制，以及为什么它可能不适合
我们，因此，让我们先大概的讨论一下PaaS的不足之处。
对于开发者来说，PaaS可以让我们的生活更容易。它可以帮助我们运行和扩展应用，而不
需要太多的担忧和负担。但是PaaS也有限制和边界，这些限制即包括了可以对代码做什么，也
包括了哪些应用可以运行在PaaS之上。
依据开发者来自哪里，在哪里工作，以及怎样使用它，PaaS的限制的表现形式是不一样
的。如果仅仅从代码的角度来看，就有许多的不足之处。一般来说，缺少一个文件系统的支持
意味着开发者必须提前思考如何对网站扩展多个实例。还有其他一些限制，例如：有时候，必
须针对平台编写特定的代码，因此，不太容易迁移。有时候对平台如何运行缺少必要的了解。
随着时间的发展，这些技术限制可能得到解决。在PaaS发展了若干代之后，我们可以看到
某些限制已经没有了。但是，仍然有其他一些限制却变得愈发难以对付。
8.4.1　将应用装入模子
对于开发者而言，他必须仔细思考要构建什么类型的应用，以及该应用是否适合PaaS模
型。股票市场上的高频率交易软件从来就不是平台即服务的理想使用案例。从长期来看，每个
微妙的性能都至关重要超级高性能的应用，也不是PaaS的理想使用场景。PaaS确实意在解决
某些比较棘手的问题。但是，在这个过程中，它只能应用于那些适合于某些标准模式的应用。
开发者往应用中加入的各种不同的特性和功能越多，那么应用能够适应PaaS模型的可能性就
越低。
这里举一个Node的例子。有些时候，开发者的应用中会同时打开两个网络端口，每个端口
独立的接收数据，并且都给这个单一的应用提供数据。PaaS的一个典型的标准就是在Internet
上只能打开一个端口，那么这个应用就不符合这个标准的要求。因此，构建的此类应用通常无
法在平台即服务上很好地运行。
巨型应用有着巨大的文件系统，非常多的功能，并且使用了若干GB的内存，因此也不适
合在PaaS的限制下运行。既然将应用分解成比较小的组件和服务比较困难，那么就更难证明
它们可以在PaaS上运行。要调试运行在产品模式的、复杂应用中的深层次的问题（取决于所采
用的PaaS）可能是非常困难和令人沮丧的事情。这一过程确实只适合本地开发环境，从而可以
深入某些运行时的细节内部，而这一点在产品环境中是无法获得的。
8.4.2　更多考虑
另外一个限制，涉及在PaaS上构建分布式应用。在高分布式应用中，开发者必须意识到消
息总线，并且了解PaaS是否允许消息总线技术运行，并且将分布式的应用进行连接。不管在分
布式应用中采用消息队列系统还是数据库系统，要确保那些相互连接的部分在PaaS环境中得
到了很好的支持，这是另外一个需要考虑的问题。
另外一些限制可能就是制度上的限制。对于中小型公司或者大型企业来说，可能有一个
运维团队专门负责运行这些应用，因此开发者通常没有选择的机会。在有些情况下，开发者自
己在PaaS完成开发，然后将应用交给运维人员，然后他们则试图将应用运行在非PaaS环境下。
因此，有些情况下，开发者可以在PaaS上开发应用，而不用去担心应用最终是如何部署的。但
另外一些场合下，这可能就成了问题。运维团队允许开发者做什么，这一文化上的隔阂，会让
应用没有办法运行在PaaS环境下。在本章的后面一些部分，我们会讨论一下文化上的一些考
虑。
而且还要考虑一下所采用的服务和数据库。如果要构建一个应用程序，需要主-主复制和
高可用性，并且系统需要若干GB的数据库存储，那么开发者就必须事先考虑这些，确保所选
定的供应商能够对这些需求提供支持。如果对这种情况不是很确定，那么此时PaaS可能并不
适合你。
总的说来，作为开发者，总应该与老板保持沟通，以确保他们了解应用程序运行在什么地
方。没有得到老板的认可也许是另外一个不允许使用平台即服务的原因。系统管理员通常会
在凌晨四点接到电话。如果出了故障，而这些人可能会对新工具和技术有所抵触。因此，要想
一切顺利，和他们保持沟通是另外一件非常重要的事情。
对于企业或者政府代理机构，数据的限制可能会非常严格，这样可能就没有办法选择采
用PaaS。如果还是可以使用私有PaaS的话，可能对于PaaS所支持的语言，以及支持到什么程度
有些限制。
某些PaaS供应商可以对以下一些应用情景提供支持，而另外一些则不允许这些应用，即
为了获取高性能而精心调试、定制自己的Ruby版本、修改运行时内部的实现（例如PHP），等
等。如果需要定制编译自己的Python版本，PaaS可能并不适合。如果需要使用特定类型的处理
器或者某些特定的硬件来运行应用，PaaS同样并不适合被采用。
最后，考虑PaaS的限制与益处的问题的时候，实际上就是一个控制的问题。开发者愿意并
且能够放弃的控制越多，那么可以利用的PaaS功能就会越多。因此，问题的两个方面就是：控
制以及可以从PaaS获取多少功能。可以从何种程度上享受PaaS所带来的好处，例如速率、速度
以及上市时间等，完全取决于开发者愿意放弃多少控制。一般说来，适应PaaS的模式的程度越
高，那么对应用运行的担忧就会越少。
8.4.3　避免限制
很容易在货比三家之后，选择一个满足要求的PaaS供应商。这其中非常重要的一点就是：
要了解设置并尝试该PaaS的难易程度。开发者应当通过在PaaS上运行第一个应用程序，从而
对其进行评估。这不仅仅是服务质量的指示器，而且也决定了在后期与这个服务供应商打交
道的质量水平。
作为一个见多识广的开发者，应当执行以下的调研：
1.在三个不同的PaaS供应商那里分别创建账号（大多数都会提供免费试用）。
2.在初步研究了不同的选项之后，深入研究其中两项最感兴趣的选项。
3.在这些PaaS供应商平台上部署一个应用。
4.尝试一下他们的核心服务。可以往数据库中存入多少数据？核心服务是否能够扩充？
5.花点时间研究一下服务的功能。是否提供消息总线？是否提供队列和缓存服务？
6.审核价格体系。
7.将这些结果汇报给老板或者运维团队。如果你是一个独立开发者，对于采用哪个，可能
早已经有了自己的答案。
如何决定PaaS的成本
平台即服务的缺点之一就是，虽然设置简单，但是却有很多不同的定价方式。这一点可能
让人无比困惑，尤其对于PaaS新手来说。当需要扩展时，这就变得非常的关键了：即愿意或者
能够花费多少钱在扩展上面？我们先来看看这个问题，记住这只不过是某个时间点上的答
案。因此，非常重要的一点，就是要注意到随着时间的发展，定价的方式也很有可能发生变
化。
以下就是对于很多PaaS供应商来说很典型的一个场景。
开发者发布了一个应用。随后，很快就发现需要处理更多的网络请求，需要扩充应用。这
对开发者的成本有什么影响呢？在2013年，很多小型的商业组织的账目是这样的，每月用于
PaaS的费用在2000~3000美元之间。当达到这个价格区间的时候，很多开发者会认为他们可以
花300美金每月租到更强大的服务器。于是，他们放弃了平台即服务，开始自己管理应用。由于
成本增长过快，他们放弃PaaS的同时也放弃了PaaS所有的好处。通常，他们也忽视了可以重新
评估其他PaaS供应商的定价结构的机会。通过对不同的供应商做一个快速的调查，也许会发
现，由于这样或者那样的原因，开发者也许可以从每月3000美元的PaaS供应商转移到只需要
每月300美元的另外一个PaaS供应商。
不同的PaaS供应商有着不同的定价方式。有些是不同层次的价格模型，有些则有更为动
态的定价尺度。使用某些供应商（例如AppFog），开发者可以免费的获取一定数量的RAM，然
后再升级到更高容量的RAM，从而可以按照需要使用在任何地方。其他供应商会提供免费的
沙盒模式，只有在升级到产品模式的时候才开始收费。例如，Heroku有一个根据使用动态收费
的模型，从而可以根据实际的资源使用情况进行收费。如果额外使用了5个应用5分钟，之后又
回到一个应用状态，那么只会按照5分钟来收费。Heroku按照应用的实例数量来收费，而不是
根据实际使用的RAM数量。
关键的总结：在正式签署合同之前一定要尝试不同的PaaS供应商，了解清楚他们可以提供
什么以及如何收费。
8.5　直面阻力
开发者热爱PaaS。但有时候，在某些组织内部会有一些团体抵制采用PaaS。老板可能从来
没有听说过PaaS，因而会感到害怕。系统管理员则会感到，PaaS将会超出其控制范围，因此会
感到工作受到了威胁。运维团队可能会认为PaaS绕过了他们。即使其他一些开发者也会有些
阻力。他们可能会认为他们知道的更多，或者可以有不同的、传统的完成工作的方式。他们可
能听说过PaaS，但是不会对其有任何积极的反应。
在和这些不同的团队打交道的时候，本书中所提到的一些事实可以被用来解释和消除他
们的忧虑。事先知晓益处和限制，向他们展示对这些的理解，然后再解释为什么PaaS是可以接
受的，这种做法就会很有说服力。
给他们解释，PaaS可以帮助人们更快地完成工作，并且更为可靠和可扩展，所有的人都不
需要担心凌晨4点被叫起来解决问题。给他们解释，当需要将应用的实例数量增加到上千个
时，只需要轻点鼠标就可以完成。这些都是令人信服的措辞。在和系统管理员以及运维人员打
交道时，开发者要准备好对PaaS的限制以及潜在陷阱的理解（表8-1）。然后再给他们解释，所
选择的PaaS供应商可以如何帮助管理风险，同时给他们展示你管理限制性的计划。准备好所
有这些说辞，将非常有助于消除来自运维以及系统管理团队的阻力。
表8-1：赞成和反对PaaS的说辞
可往表8-1中的空白部分填入更多的、特定于应用需求的益处和限制。在之前的中讨论了
很多权衡的问题。
8.6　以长远的视角看待限制
在我们即将完成对PaaS限制性的讨论之时，重要的一点就是要记住，下一代的PaaS将会
变得越来越强大。平台即服务是和虚拟化一样重要而具有颠覆性的技术，我们将会看到它日
益标准化。随着PaaS的演化，它将逐渐成为像今天的虚拟化一样的支撑技术。在2010年末，它
将成为大规模运行应用程序的事实上的标准。
我们尚未看到在PaaS运行诸如Facebook和Twitter之类的大型应用程序。当然，通过本章中
所讨论的一些限制可以看到“为什么PaaS不适合这些类型的应用”。PaaS是为了稍低级别规模
的应用而构建的。PaaS可以帮着应用成长为Facebook或者Twitter，但是，过去我们还没有看到
PaaS被应用在如此大规模的应用系统上。虽然，今天我们还没有看到这样的事情发生，但是，
最终有一天PaaS会为帮助下一代应用获得巨大的成功。
PaaS所带来的益处会持续增加，而限制则会不断减少。虽然，现在可能有些原因导致不会
选择在PaaS上运行应用，但是那些最终尝试在PaaS上运行应用的先行者们，必然能够比他们
的同僚更快地完成工作。他们将会因为做出了明智的选择而获得提拔，并且会获得前瞻思想
家的荣誉，面向未来构建应用的前瞻性思考者。
第9章　PaaS的未来
在前面的章节中，我们已经涉及了平台即服务的未来可能会是什么样子的话题。随着技
术难题被不断的攻克，PaaS越来越成熟，因此正在应用开发中起着越来越重要的角色。但是，
与PaaS的未来同样重要的是IaaS技术的不断发展和影响力的不断扩大。为数众多的IaaS的应用
编程接口（API）可能会让开发者感到困惑，因此，PaaS提供了一个更为简单的全局观，可以让
开发者更快地完成工作。
9.1　OpenStack的影响
PaaS通常和基础设施即服务紧密相关。诸如Heroku和EngineYard之类的早期的PaaS公司，
采用亚马逊的Web服务作为他们的IaaS供应商。随着PaaS的持续发展，在IaaS中产生了一项重
要的技术变革。而这一切都始于一个简单的问题：如果亚马逊的Web服务技术开源了会怎样？
在2010年7月，Rackspace和美国国家航空航天局（NASA）联合发布了一项新的开源项目，
称之为OpenStack（http://www.openstack.org/）。其思路是要创建世界上第一个开源的IaaS项目。
第一批贡献的代码来自于NASA的Nebula平台（称为Nova）和Rackspace的云文件平台（称为
Swift）。OpenStack的前景是巨大的，如果可以成功构建，那么理论上说任何人都可以运行自己
的类似亚马逊Web服务（AWS）一样的服务。然而，如此诱人的前景执行起来却并不乐观。开始
的时候，有太多的关于软件是如何不成熟的抱怨。但是，OpenStack还是很快的成熟起来了，并
且变得日益稳定和功能丰富。
在诞生之后的几年里，OpenStack取得了很大的成功，如今至少有两个任何开发者都可以
使用的大型公共云基于这一项目，一个来自于Rackspace，另一个则来自HP。IBM、Dell以及很
多其他公司都计划在他们未来的关键产品中采用OpenStack。可以毫不夸张地说，数以百计的
公司，不管规模是大还是小，都在给OpenStack贡献时间、金钱以及资源，这让OpenStack空前成
功。
OpenStack的成功是如此令人瞩目，以至于其他的一些项目纷纷效仿。例如CloudStack，开
始的时候它是闭源的，如今也开源了，基于Apache 2.0许可证，由Apache基金会负责管理。
OpenStack的成功给公共云和私有云的应用创造了可能性，也给PaaS的构建提供了更多的
选择。由于很多PaaS技术都依赖于获取服务器的API，同时由于OpenStack和CloudStack如今为
了在私有云上实现这一点提供了选择，因此，PaaS在公共和私有云领域正发挥着愈来愈重要
的作用。
如今，OpenStack的应用在诸如Rackspace之类的公司之中掀起了一波IaaS应用的浪潮。刚
起步的时候，Rackspace是一个托管主机供应商，提供托管服务和托管服务器。由于其希望提
供基于OpenStack的托管平台，这个公司在OpenStack的开发过程中占据了领先的位置。
OpenStack和亚马逊的Web服务类似，但是所采用的技术可以应用在不同的场合之中。
Rackspace做到了这一点，如今已经拥有了一个运行于OpenStack之上的云系统，可以在公共云
和私有云领域提供服务。
9.2　保持开发选项的开放
在决定IaaS供应商的时候，开发者通常会发现有非常多的选择。但是，在提供了这些选择
的同时，这些供应商常常会让人感到眼花缭乱和无所适从。
开发者可以选择采用现有的亚马逊的Web服务，或者也可以尝试OpenStack或者
CloudStack，但是要准备好学习所有这些不同的API。开发者也可以选择一个专有系统，例如
Joyent或者Azure，这些系统拥有更为私有的API。因此，在构建应用的时候，应用会越来越与所
选定的平台绑定在一起。IaaS的本质就是将开发者绑定在某个基础设施供应商之上。使用的越
多，对其依赖性越强。
作为开发者，首要的事情就是完成工作。获取必要的资源然后运行应用。然而，考虑到不
同平台的API的复杂性和差异性，在这些不同的平台上创建新的基础设施就成了问题。而且，
搞清楚在不同的基础设施上使用IaaS的接口也是一件非常乏味的事情，没有多少乐趣可言。
PaaS则具备了在不同的基础设施上运行的能力，同时也可以将这些基础设施进行整合让
它们看起来没有什么不同。我们的PaaS运行在OpenStack上与运行在AWS或者CloudStack上是
类似的。在一个私有云上运行的版本与在一个公共云上运行的版本也没有什么不同。因此，这
就赋予了PaaS较之于IaaS更大的灵活性。它可以运行于拥有不同API的环境下，所以，对开发
者而言，不需要去为搞清楚这些差异而大伤脑筋。当开发者创建应用程序，并试图在不同的基
础设施上运行时，这将节省大量的时间。
9.3　故障：开发者必须面对的最大问题
将基础设施运行在不同供应商的平台上将是一件异常困难的事情。开发者不仅需要搞清
楚所有这些不同的API，而且还得弄明白如何在这些环境下对应用程序进行监控和维护，这同
样也是一项无比艰巨的任务。更让人头疼的是，开发者还得应付大规模的云系统故障。
看起来情况是这样的，即每隔一个星期都会有一个大型云服务供应商宕掉，同时半个互
联网也随之停止服务。这就引发了另外一个非常重要的问题，也许是每个开发者在过去10年
里面都必须面对的最重要的问题。
如何在基础设施，以及数据中心不是那么的可靠和健壮的情况下，构建一个稳定、可靠和
健壮的应用程序？
作为一个现代开发者，他可能会质疑将应用运行在一个单一的供应商，是否是一个足够
好的解决方案。是否可以充分的信任一个单一的IaaS供应商或者某个地域范围内的供应商逐
渐成为一个难以回答的问题。如果开发者不相信基础设施供应商，那么最终的结果自然是很
难管理。以下是一些需要额外考虑的问题：
·当应用同时运行于两个不同的供应商时（即AWS以及Rackspace或者HP和Azure），如何管
理失效恢复，应用冗余以及高可用性？
·如何确保代码运行在同样的系统上，数据可以被访问？
·当其中某个数据中心出故障的时候，如何处理？
·在关键的时刻，如何确保网站顺利运行？
这些都是非常难以回答的问题，不同的IaaS技术让这些问题难上加难。OpenStack通过提
供在公共云和私有云上的解决方案使得这些问题得以解决，但是在公共云和私有云上采用相
同的IaaS技术只是解决方案的一部分。基础设施供应商们选择的技术不同，相应的方案也有所
不同，这些不同之处使得高可用性以及失效恢复这些问题变得更加难以考虑。
因此，PaaS拥有极大的机会，即在技术栈中居于相对高一层位置的机会。平台即服务可以
为开发者们思考和管理IaaS。它可以理解OpenStack的API，与如何理解AWS的API一样，然后，
让这些API对于开发者来说变得更为透明。
采用PaaS，开发者不需要了解底层的基础设施如何以不同的方式被使用，构建和管理。这
一点给予了PaaS惟一的功能，即在基础设施之上高一个层次提供对系统的洞悉。同时，相对于
IaaS层次而言，PaaS也把对失效恢复和高可用性的思考变得更为容易。如果要在公共云和私有
云上使用OpenStack，失效恢复和高可用性的可选方案可能早已具备，而这些在其他地方是找
不到的。但是，不采用PaaS而要配置和管理两个数据中心依然是一件让人头疼的难以置信的
事情。
我们所生活的世界中，要想在所有的地方采用同一项技术实现的可能性越来越小。这意
味着我们不得不去面对一个闭源的私有系统，这一系统从根本上说与我们内部运行的系统是
不同的。这就是PaaS被证明了的价值之所在。它可以参与进来，弥补IaaS无法做到的鸿沟。
9.4　通过开源重新获取控制
开源的PaaS方案，如Cloud Foundry、OpenShift以及Cloudify等，利用社区的领先力量，以一
种稳定持续的方式将广泛而深入的运维知识融入到PaaS之中。
最早由Derek Collison在VMware所编写的Cloud Foundry是由超过一打的程序所组成的工
具集，这些程序松散耦合，一起工作以提供PaaS的功能。要注意的是，Cloud Foundry本身并不
能提供本书中所描述的PaaS的所有功能。而且，自己动手安装、设置和运行Cloud Foundry可能
是一件非常困难的事情。幸运的是，有些供应商已经为我们完成了这些艰难的任务，例如
AppFog和CloudFoundry.com（http://cloudfoundry.com/）。而且，有一些方法可以在笔记本电脑上
简单的设置为以开发模式运行的Cloud Foundry。但是，如同OpenStack一样，只有整个团队使用
它的时候，才能体现其强大的功能。
但是，Cloud Foundry库还是提供了开发者所期望的，PaaS上的许多功能，例如：采用命令
行接口将应用部署到一个基于REST的API之上；不需要任何配置就可以对应用进行扩展和负
载均衡；增加诸如MySQL和Redis之类的数据库和缓存服务，等等。采用Cloud Foundry，可以很
快地完成必要的准备工作并且运行应用。但是，在出故障的情况下，开发者得具备一定的运维
知识，知道如何调试Cloud Foundry从而找出问题所在。开发者还需要了解在MySQL增长的时
候，如何对其进行维护和扩展。
开发者对于PaaS最有疑虑的一点就是：采用了PaaS之后就会放弃很多的控制，不得不按部
就班的按照PaaS供应商所要求的那样去做。诸如Cloud Foundry和OpenShift的开源库正在开始
破除这一疑虑。由于它们是完全开源的，因此开发者就可以深入到这些库的核心，以了解
Apache和MySQL是如何被配置的。我们还可以创建新的运行时支持，例如Erlang社区就给
Cloud Foundry加入了对Erlang的支持。
简而言之，在开源PaaS技术的后面有很多发展得比较成熟的技术，这些技术使得在开发
下一代PaaS服务的时候，采用开源PaaS技术成为一项强有力的选择。
9.4.1　微魔术
采用开源的PaaS库的时候，开发者要做的第一件事情就是让本地拷贝运行起来。有多种
不同的方法可以做到这一点。
Cloud Foundry提供了一个称为微Cloud Foundry（Micro Cloud Foundry）的产品，可以被用于
运行本地云。这个产品可以运行在Mac、个人电脑、甚至Linux之上，基本上说可以运行在任何
运行VMware Player、Workstation或者Fusion的系统之上。微Cloud Foundry包括了几乎所有独立
的服务，因此可以在一个单一的虚拟机上运行Cloud Foundry的所有功能。
但是，它并不像一个产品级Cloud Foundry那么成熟。例如，Cloud Foundry知道如何做出判
断，比如说，在同一台机器上运行着5个应用，在这台机器宕机的情况下，只要后备池中有其他
的虚拟机可以运行程序，Cloud Foundry就会自动将应用重新部署到可用的虚拟机上。
Vagrant是另外一个可以被用来简单、快速地设置本地定制化虚拟机的开源库。红帽子
（Red Hat）提供了如何设置一个OpenShift实例的详细指导，但是，自己做起来还是可能比较单
调乏味。因此，另外一个可选的方法就是利用诸如Vagrant之类的技术替我们完成这些工作。有
些人早已完成了类似工作，并且将工作成果开源了。
要设置诸如Cloudify之类的，可以自举的本地PaaS库拷贝可能更加容易。它们已经被构建
成私有PaaS方案，就是说通常可以比较容易的对它们进行安装设置。Cloudify提供了非常不错
的上手指南。
这里有一些资源可供参考：
·Micro Cloud Foundry（https://micro.cloudfoundry.com/）
·Vagrant（http://www.vagrantup.com/）
·如何设置OpenShift（https://openshift.redhat.com/community/wiki/build-your-own）
·用于OpenShift的Vagrant文件（https://github.com/mojolingo/puppet-openshift）
·Cloudify设置指南（http://www.cloudifysource.org/guide/）
9.4.2　开源PaaS库的限制之处
PaaS库依然需要进行管理和维护，很多开源的PaaS都给出了类似的限制。因此，作为开发
者来说，在不了解这些限制的情况下去运行一个PaaS库可能是一件令人毛骨悚然的事情。
限制之一就是一个PaaS库通常无法启动多个IaaS服务器。即使拥有了一个可以被用于部
署代码的应用服务器的后备池，在这个后备池中的每台机器都宕机的情况下，Cloud Foundry
不知道如何可以启动更多的服务器并加入这个后备池。它不知道如何操作整个系统，不知道
如何对自身进行监控和维护。这些对于试图运行Cloud Foundry的小公司，甚至大公司来说都
是非常繁琐的工作。
对某个PaaS库的组件进行监控、管理和维护可能是一个非常大的挑战。但是这些技术本
身却代表了PaaS未来的发展趋势。它可以被以一种分布式的方式运行，可以运行在公共和私
有云，甚至笔记本电脑上。因此，了解PaaS库可以带来极大的灵活性非常重要，包括知道如何
利用这一灵活性。
9.4.3　多功能的优点
PaaS可以很好地适用于开源项目的原因之一，就是因为它可以处理一项巨大的挑战。如
果某个公司精通于PHP或者Python或者Perl，那么为PHP、Python或者Perl构建一个PaaS将是可
管理的任务。但是，要编写一个可以运行在Python、Perl、PHP、Java、.NET、Node以及任何可以
被想到的技术上的PaaS，将是非常困难的。能够运行很多不同的技术，以及精通于这些技术，
这是PaaS的一项重要资产。
这一多功能的特性利用了开源运动的一个关键优势。能够基于开源合作者的工作进行构
建的能力，以及这些开源合作者对社区的贡献就是PaaS可以和开源项目配合得如此之好的重
要原因。
9.5　最终的思考
在未来，我们将会看到越来越多的试图构建一个持久的PaaS服务的尝试，这个服务试图
解决一个重要问题，即开发者想要使用PaaS，但是现在无论对于大公司，还是小公司来说，要
采用PaaS都比较困难。但是，随着时间的发展，我们将会看到越来越多的公司致力于解决这一
问题，从而开发者可以以他们自己期望的方式编写代码。
PaaS将会不断地被开发者们所采用。他们将会更多地思考采用PaaS的不同方式，同时也
会开始尝试克服PaaS限制的方法并且以更具创造性的方式使用PaaS。平台则会考虑更多的使
用场景，变得更加灵活，并提供更高的性能。但是，开发者如今真的可以享受到PaaS所带来的
好处。这就是推动PaaS作为一个开发方法学持续前进的动力，这一方法学将随着下一代应用
程序的发展而持续不断地发展。
第10章　资源
贯穿本书始终，讨论了多种不同的工具和技术。因此，在这最后一章中分门别类地给出了
一个资源的列表。由于PaaS和其相关的服务一直处于不断地发展之中，所以没有办法列出一
个完全真正不变的列表。但是，以下这些链接至少可以给大家提供一个研究的起点。
10.1　PaaS供应商
PaaS供应商有多种不同的类别。因此，有时候要分辨出哪个比较适合我们的需求比较困
难。但是在考虑以下这些问题的时候，还是可以了解到他们之间的一些比较大的差别：供应商
可以提供哪些语言支持；应用在PaaS平台上的移植性；PaaS运行的基础设施；开发者是否负载
运行PaaS或者由供应商来做这些事情。以下这些术语很重要，必须铭记在心：
移植性
如果开发者可以比较容易地将应用从一个PaaS供应商迁移到另外一个，那么这两个都将
可以作为可移植的PaaS备选方案。如果来自传统开发过程的代码，不需要经过太多的修改就
可以运行在一个PaaS上，那么这个PaaS就是可移植的。例如，如果PaaS支持PHP，并且开发者
可以将一个基于WordPress的PHP程序上传到该PaaS，而不需要修改WordPress底层的基础代
码，那么这就是一个可移植性的PaaS。
不可移植
一个与专有的API绑定的PaaS，使得应用比较难以迁移到另外一个PaaS供应商，就是一个
不可移植的PaaS。
公共云
任何部署在诸如AWS和Rackspace之类的公共云上的PaaS都是公共云PaaS。
私有云
任何运行在开发者的防火墙之后，运行在开发者自己的基础设施之上的PaaS都是私有云
PaaS。
托管
托管PaaS就是那些开发者不需要自己去运维的PaaS，开发者可以将它们当服务使用。
非托管
非托管的PaaS就是那些需要自己去手工安装设置、解决安全问题、维护、运行、更新的
PaaS。
下面是一个当今PaaS供应商的列表。
AppFog：可移植性、托管、公共和私有云
如今被CenturyLink（http://www.centurylink.com/）所拥有的AppFog（http://www.appfog.com/）
是首批对PHP提供一流支持的PaaS之一。随着之后的日益流行，它得到了进一步的扩展，支持
Node.js、Ruby、Python以及Java语言的解决方案。
Apprenda：不可移植、非托管、公共和私有云
Apprenda（http://www.apprenda.com/）专注于为防火墙之后的企业级PaaS应用服务，
对.NET和Java提供深度的支持和集成。它给传统的.NET和Java应用增加了SaaS功能。
CloudBees：可移植性、托管、公共和私有云
刚开始的时候CloudBee（http://www.cloudbees.com/）是一个只支持Java的PaaS，集成了
Java平台上的通用工具。之后扩展为支持大多数语言，包括Node.js、Go、Erlang以及其他语言。
CloudBees还出色地集成了Jenkins，以提供持续集成的能力。
Cloud Foundry：可移植性、非托管、公共和私有云
Cloud Foundry（http://www.cloudfoundry.com/use）提供了一组数十个程序，这些程序松散耦
合，一起工作以提供PaaS功能。
DotCloud：可移植性、托管、公共云
DotCloud（https://www.dotcloud.com/）是第一个支持多种语言和技术的PaaS。它支持Ruby、
Node.js、Python、PHP和Java。
EngineYard：可移植性、托管、公共云
EngineYard（http://www.engineyard.com/）是首批拥有数千个产品级应用客户的PaaS公司之
一。它支持Ruby、PHP以及Node。开发者对于他们的虚拟服务器有着完全的访问控制，同时，
不论大小，在控制和自动化整个环境方面还拥有专家级技巧的灵活性。EngineYard备受赞赏的
DevOps和支持团队在应用分析、代码和安全审计、定制化专家方案、部署、扩展，以及高可用
性策略方面具有专家级的知识和经验。
Force.com：不可移植、托管、公共云
Force.com（http://www.force.com/）是一个对SalesForce的数据进行直接访问的专有PaaS。
它可以围绕客户关系管理（CRM）数据构建一个生态系统。
Google App Engine：半可移植、托管、公共云
Google App Engine（https://developers.google.com/appengine/）是PaaS的最早形式之一，拥有
一大批追随者以及背后广大的注意力份额。它可以充分利用Google的强大功能的前景，让它
成为PaaS领域的领导者。
Google App Engine开始的时候是一个不可移植的PaaS，但是现在正转向可移植，甚至在额
外的PHP的支持下还可以运行WordPress应用。
Heroku：可移植性、托管、公共云
Heroku是最早的云平台之一。它可以支持Ruby、Java、Python、Clojure、Scala、Node.js以及
其他语言。
微软Azure：半可移植、托管、公共云
Azure一开始也不可移植，但是现在正逐渐变得可以移植。微软还提供了可以独立的扩展
的标准服务。
10.2　IaaS供应商
如果要使用虚拟服务器，IaaS是最快的方式。通过IaaS供应商，开发者可以获得专有的服
务器和专有的IP地址。由于是从零开始，开发者必须自己去做所有的工作，包括系统管理、软
件安装、调整和管理。开发者可以采用很多本章中列出的私有云、非托管的PaaS供应商。
亚马逊Web服务
AWS（http://aws.amazon.com/）是当前最流行的IaaS。亚马逊采用Xen来对其跨越世界上数
十个区域的基础设施进行虚拟化。
DataPipe
DataPipe（http://datapipe.com/）提供自己的基础设施，同时也在亚马逊的Web服务基础之上
构建了更多的托管服务并重新销售。这些额外的服务包括监控、补丁升级、变更管理、部署以
及其他。
GoGrid
GoGrid（http://www.gogrid.com/）是一个高性能的基于IaaS的托管供应商。
Google计算引擎
Google（http://cloud.google.com/products/compute-engine.html）构建了自己的IaaS，并和亚马
逊以及其他供应商竞争。在同等的价格点上，性能要比亚马逊高出很多。
HP云服务
HP云（http://hpcloud.com/）在IaaS市场上相对较新。它是一个构建于OpenStack之上的公共
云，运行在世界各地的多个HP数据中心上。
Joyent
Joyent（http://joyent.com/）是面向大型企业的IaaS供应商。与传统的虚拟化OS的IaaS供应商
不同的是，Joyent采用自己的SmartOS技术（基于Solaris），结合了ZFS、DTrace、Zone以及KVM，
因此比传统的虚拟技术有着更好的性能特性。
OpenStack
OpenStack（http://www.openstack.org/）是由多个组件构成的开源库，这些组件在于模拟诸
如AWS的IaaS供应商的API体验。
OpenStack中的组件包括：
·计算（https://github.com/openstack/nova）（代号Nova）
·对象存储（https://github.com/openstack/swift）（代号Swift）
·块存储（https://github.com/openstack/cinder）（代号Cinder）
·网络（https://github.com/openstack/quantum）（代号Quantum）
·仪表板（https://github.com/openstack/horizon）（代号Horizon）
·识别服务（https://github.com/openstack/keystone）（代号Keystone）
·图像服务（https://github.com/openstack/glance）（代号Glance）
Rackspace
Rackspace（http://www.rackspace.com/）提供对Linux和Windows的非常完美的支持。
Rackspace和NASA是OpenStack最初的开发商，并且将OpenStack用于运行其公共云IaaS。
Savvis
Savvis（http://www.savvis.com/）（现在为CenturyLink所拥有）是一个大型的、面向企业的、
基于VMware的公共云的、提供可选托管服务的IaaS供应商。Savvis所运行的服务器可以是完
全托管的，而且Savvis可以完成软件的升级。
TerreMark
TerreMark（http://www.terremark.com/）（现在为Verizon所拥有）是另外一个大型的、面向企
业的、基于VMWare的公共云Iaas供应商。不同于按虚拟机实例数量进行销售，它是按照资源块
的数量进行销售。
微软Azure
虽然Azure起步于PaaS应用，现在也拥有了IaaS功能。其对Windows的支持是非常完美的，
而且甚至也支持Linux。但是，现在Linux虚拟机的数量在一个子网内部最多只能有20台。因此，
它可能无法像这个列表中的其他供应商一样对Linux进行很好地扩展。
10.3　托管服务
在采用托管服务时，事先计划相当关键。要事先考虑如何克服任一特定的服务的扩展性
限制。在考虑了这些所有的可能场景之后，从托管的服务开始总是比自己设置要快些。以下列
出了其中的一些选择。
10.3.1　数据存储：MySQL
·ClearDB（http://www.cleardb.com/）
·亚马逊RDS（http://aws.amazon.com/rds/）
10.3.2　数据存储：PostgreSQL
·Heroku Postgres（https://postgres.heroku.com/）
10.3.3　数据存储：CouchDB
·IrisCouch（http://www.iriscouch.com/）
10.3.4　数据存储：MongoDB
·MongoLab（https://mongolab.com/）
·MongoHQ（https://www.mongohq.com/）
10.3.5　数据存储：NoSQL
·Coudant（https://cloudant.com/）
·Neo4j（http://www.neo4j.org/）
10.3.6　数据存储：Redis
·Redis To Go（http://redistogo.com/）
·OpenRedis（https://openredis.com/）
·Redis Cloud（http://redis-cloud.com/）
10.3.7　数据存储：缓存
·MemCachier（https://www.memcachier.com/）
·IronCache（http://www.iron.io/cache）
10.3.8　移动应用
·Urban Airship（http://urbanairship.com/）
·Pusher（http://pusher.com/）
·Realtime.co（http://www.realtime.co/）
·PubNub（http://www.pubnub.com/）
·Twilio（http://www.twilio.com/）
10.3.9　搜索
·Searchify（https://www.searchify.com/）
·Websolr（http://www.websolr.com/）
·AWS CloudSearch（http://aws.amazon.com/cloudsearch/）
·Treasure Data（http://www.treasure-data.com/）
10.3.10　日志
·Loggly（http://loggly.com/）
·Logentries（http://logentries.com/）
·Papertrail（https://papertrailapp.com/）
10.3.11　邮件
·Mailgun（http://www.mailgun.com/）
·Sendgrid（http://sendgrid.com/）
·CloudMailin（http://www.cloudmailin.com/）
10.3.12　后台任务
·IronMQ（http://www.iron.io/mq）
·IronWorker（http://www.iron.io/worker）
·CloudAMQP：（http://www.cloudamqp.com/）RabbitMQ作为服务
10.3.13　分析
·Statsmix（http://www.statsmix.com/）
·NewRelic（http://newrelic.com/）
·Blitz（http://blitz.io/）
10.3.14　错误监测
·Exceptional（http://www.exceptional.io/）
·Airbrake（https://airbrake.io/pages/home）
10.3.15　工具
·Zerigo（http://www.zerigo.com/）：DNS
·CloudFlare（https://www.cloudflare.com/）：CDN+安全+分析
·Codeship（https://www.codeship.io/）：托管的持续集成/持续部署工具
10.3.16　支付
·Recurly（http://recurly.com/）
·Stripe（https://stripe.com/）
·Spreedly（https://spreedly.com/）
10.4　将遗留应用迁移到PaaS
遗留应用可能有多种不同的形式，从博客到内容管理系统，再到某些相当长时间之前用
某个已经被遗忘了的语言开发的定制应用。以下针对常见的博客和内容管理系统，给出一些
资源链接，当开发者需要将博客或者其他应用更“云”化时，可以提供一些帮助。
10.4.1　WordPress插件
·UpdraftPlus备份（http://wordpress.org/extend/plugins/updraftplus/）
·CDN同步工具（http://wordpress.org/extend/plugins/cdn-sync-tool/）
·亚马逊S3上传工具（http://wordpress.org/extend/plugins/amazon-s3-uploads/）
10.4.2　Drupal模块
·存储API（http://drupal.org/project/storage_api）
·亚马逊S3（http://drupal.org/project/amazon_s3）
·Cloud文件（http://drupal.org/project/cloud_files）
·S3自动推送工具（http://drupal.org/project/s3autopush）
10.4.3　Joomla！插件
·JA亚马逊S3（http://tinyurl.com/ja-amazon-s3）
·jomCDN（http://tinyurl.com/jomcdn）
10.5　新兴PaaS应用开发
在开发PaaS上的新应用的时候，推荐将它们构建成基于REST的。有很多框架可以很好地
生成基于任何语言的支持REST的应用。这里给出一个甄选过的流行的框架列表，当然也有很
多相当不错的没有出现在这个列表中，但是这足够帮助开发者开始了。
10.5.1　Ruby
·Ruby on Rails（http://rubyonrails.org/）
·Sinatra（http://www.sinatrarb.com/）
·RESTRack（http://restrack.me/）
10.5.2　Python
·Django REST框架（http://django-rest-framework.org/）
·Flask（http://flask.pocoo.org/）
·Bottle（http://bottlepy.org/）
10.5.3　Node.js
·Express（http://expressjs.com/）
·Tower（http://towerjs.org/）
·Restify（http://mcavage.github.com/node-restify/）
10.5.4　PHP
·Slim（http://www.slimframework.com/）
·Recess（http://www.recessframework.org/）
·Tonic（http://peej.github.com/tonic/）
10.5.5　Java
·Restlet（http://www.restlet.org/）
·Jersey（http://jersey.java.net/）
·Spring（http://www.springsource.org/）
10.5.6　.NET
·OpenRasta（http://openrasta.org/）
·WCF（http://msdn.microsoft.com/en-us/library/dd456779.aspx）
·RESTful.NET（O’eilly）（http://shop.oreilly.com/product/9780596519216.do）
10.5.7　Perl
·Mojolicious（http://mojolicio.us/）
·Dancer（http://perldancer.org/）
·Catalyst（http://www.catalystframework.org/）
